/* MAVLink2Lua - generated by mavgen_lua.py - DO NOT EDIT! */

#include "mavlink2lua.h"

#include <common/mavlink.h>
#include <ardupilotmega/mavlink.h>
#include "opentx.h"

#include <common/mavlink_msg_heartbeat.h>
#include <common/mavlink_msg_sys_status.h>
#include <common/mavlink_msg_system_time.h>
#include <common/mavlink_msg_ping.h>
#include <common/mavlink_msg_change_operator_control.h>
#include <common/mavlink_msg_change_operator_control_ack.h>
#include <common/mavlink_msg_auth_key.h>
#include <common/mavlink_msg_set_mode.h>
#include <common/mavlink_msg_param_request_read.h>
#include <common/mavlink_msg_param_request_list.h>
#include <common/mavlink_msg_param_value.h>
#include <common/mavlink_msg_param_set.h>
#include <common/mavlink_msg_gps_raw_int.h>
#include <common/mavlink_msg_gps_status.h>
#include <common/mavlink_msg_scaled_imu.h>
#include <common/mavlink_msg_raw_imu.h>
#include <common/mavlink_msg_raw_pressure.h>
#include <common/mavlink_msg_scaled_pressure.h>
#include <common/mavlink_msg_attitude.h>
#include <common/mavlink_msg_attitude_quaternion.h>
#include <common/mavlink_msg_local_position_ned.h>
#include <common/mavlink_msg_global_position_int.h>
#include <common/mavlink_msg_rc_channels_scaled.h>
#include <common/mavlink_msg_rc_channels_raw.h>
#include <common/mavlink_msg_servo_output_raw.h>
#include <common/mavlink_msg_mission_request_partial_list.h>
#include <common/mavlink_msg_mission_write_partial_list.h>
#include <common/mavlink_msg_mission_item.h>
#include <common/mavlink_msg_mission_request.h>
#include <common/mavlink_msg_mission_set_current.h>
#include <common/mavlink_msg_mission_current.h>
#include <common/mavlink_msg_mission_request_list.h>
#include <common/mavlink_msg_mission_count.h>
#include <common/mavlink_msg_mission_clear_all.h>
#include <common/mavlink_msg_mission_item_reached.h>
#include <common/mavlink_msg_mission_ack.h>
#include <common/mavlink_msg_set_gps_global_origin.h>
#include <common/mavlink_msg_gps_global_origin.h>
#include <common/mavlink_msg_param_map_rc.h>
#include <common/mavlink_msg_mission_request_int.h>
#include <common/mavlink_msg_safety_set_allowed_area.h>
#include <common/mavlink_msg_safety_allowed_area.h>
#include <common/mavlink_msg_attitude_quaternion_cov.h>
#include <common/mavlink_msg_nav_controller_output.h>
#include <common/mavlink_msg_global_position_int_cov.h>
#include <common/mavlink_msg_local_position_ned_cov.h>
#include <common/mavlink_msg_rc_channels.h>
#include <common/mavlink_msg_request_data_stream.h>
#include <common/mavlink_msg_data_stream.h>
#include <common/mavlink_msg_manual_control.h>
#include <common/mavlink_msg_rc_channels_override.h>
#include <common/mavlink_msg_mission_item_int.h>
#include <common/mavlink_msg_vfr_hud.h>
#include <common/mavlink_msg_command_int.h>
#include <common/mavlink_msg_command_long.h>
#include <common/mavlink_msg_command_ack.h>
#include <common/mavlink_msg_manual_setpoint.h>
#include <common/mavlink_msg_set_attitude_target.h>
#include <common/mavlink_msg_attitude_target.h>
#include <common/mavlink_msg_set_position_target_local_ned.h>
#include <common/mavlink_msg_position_target_local_ned.h>
#include <common/mavlink_msg_set_position_target_global_int.h>
#include <common/mavlink_msg_position_target_global_int.h>
#include <common/mavlink_msg_local_position_ned_system_global_offset.h>
#include <common/mavlink_msg_hil_state.h>
#include <common/mavlink_msg_hil_controls.h>
#include <common/mavlink_msg_hil_rc_inputs_raw.h>
#include <common/mavlink_msg_hil_actuator_controls.h>
#include <common/mavlink_msg_optical_flow.h>
#include <common/mavlink_msg_global_vision_position_estimate.h>
#include <common/mavlink_msg_vision_position_estimate.h>
#include <common/mavlink_msg_vision_speed_estimate.h>
#include <common/mavlink_msg_vicon_position_estimate.h>
#include <common/mavlink_msg_highres_imu.h>
#include <common/mavlink_msg_optical_flow_rad.h>
#include <common/mavlink_msg_hil_sensor.h>
#include <common/mavlink_msg_sim_state.h>
#include <common/mavlink_msg_radio_status.h>
#include <common/mavlink_msg_file_transfer_protocol.h>
#include <common/mavlink_msg_timesync.h>
#include <common/mavlink_msg_camera_trigger.h>
#include <common/mavlink_msg_hil_gps.h>
#include <common/mavlink_msg_hil_optical_flow.h>
#include <common/mavlink_msg_hil_state_quaternion.h>
#include <common/mavlink_msg_scaled_imu2.h>
#include <common/mavlink_msg_log_request_list.h>
#include <common/mavlink_msg_log_entry.h>
#include <common/mavlink_msg_log_request_data.h>
#include <common/mavlink_msg_log_data.h>
#include <common/mavlink_msg_log_erase.h>
#include <common/mavlink_msg_log_request_end.h>
#include <common/mavlink_msg_gps_inject_data.h>
#include <common/mavlink_msg_gps2_raw.h>
#include <common/mavlink_msg_power_status.h>
#include <common/mavlink_msg_serial_control.h>
#include <common/mavlink_msg_gps_rtk.h>
#include <common/mavlink_msg_gps2_rtk.h>
#include <common/mavlink_msg_scaled_imu3.h>
#include <common/mavlink_msg_data_transmission_handshake.h>
#include <common/mavlink_msg_encapsulated_data.h>
#include <common/mavlink_msg_distance_sensor.h>
#include <common/mavlink_msg_terrain_request.h>
#include <common/mavlink_msg_terrain_data.h>
#include <common/mavlink_msg_terrain_check.h>
#include <common/mavlink_msg_terrain_report.h>
#include <common/mavlink_msg_scaled_pressure2.h>
#include <common/mavlink_msg_att_pos_mocap.h>
#include <common/mavlink_msg_set_actuator_control_target.h>
#include <common/mavlink_msg_actuator_control_target.h>
#include <common/mavlink_msg_altitude.h>
#include <common/mavlink_msg_resource_request.h>
#include <common/mavlink_msg_scaled_pressure3.h>
#include <common/mavlink_msg_follow_target.h>
#include <common/mavlink_msg_control_system_state.h>
#include <common/mavlink_msg_battery_status.h>
#include <common/mavlink_msg_autopilot_version.h>
#include <common/mavlink_msg_landing_target.h>
#include <common/mavlink_msg_estimator_status.h>
#include <common/mavlink_msg_wind_cov.h>
#include <common/mavlink_msg_gps_input.h>
#include <common/mavlink_msg_gps_rtcm_data.h>
#include <common/mavlink_msg_high_latency.h>
#include <common/mavlink_msg_vibration.h>
#include <common/mavlink_msg_home_position.h>
#include <common/mavlink_msg_set_home_position.h>
#include <common/mavlink_msg_message_interval.h>
#include <common/mavlink_msg_extended_sys_state.h>
#include <common/mavlink_msg_adsb_vehicle.h>
#include <common/mavlink_msg_collision.h>
#include <common/mavlink_msg_v2_extension.h>
#include <common/mavlink_msg_memory_vect.h>
#include <common/mavlink_msg_debug_vect.h>
#include <common/mavlink_msg_named_value_float.h>
#include <common/mavlink_msg_named_value_int.h>
#include <common/mavlink_msg_statustext.h>
#include <common/mavlink_msg_debug.h>


void push_value(lua_State* L, const char* name, const char* text)
{
    lua_pushstring(L, name);
    lua_pushstring(L, text);
    lua_rawset(L, -3);
}

void push_value(lua_State* L, const char* name, const double num)
{
    lua_pushstring(L, name);
    lua_pushnumber(L, num);
    lua_rawset(L, -3);
}

void push_value(lua_State* L, const int i, const char* text)
{
    lua_pushnumber(L, i);
    lua_pushstring(L, text);
    lua_rawset(L, -3);
}

void push_value(lua_State* L, const int i, const double num)
{
    lua_pushnumber(L, i);
    lua_pushnumber(L, num);
    lua_rawset(L, -3);
}

void provide_MavlinkStatus(lua_State* L, const mavlink_status_t& status)
{
    TRACE("provide_MavlinkStatus(%x)", L);
    assert(L);

    lua_newtable(L);
    push_value(L, "msg_received", status.msg_received);
    push_value(L, "buffer_overrun", status.buffer_overrun);
    push_value(L, "parse_error", status.parse_error);
    push_value(L, "parse_state", status.parse_state);
    push_value(L, "packet_idx", status.packet_idx);
    push_value(L, "current_rx_seq", status.current_rx_seq);
    push_value(L, "current_tx_seq", status.current_tx_seq);
    push_value(L, "packet_rx_success_count", status.packet_rx_success_count);
    push_value(L, "packet_rx_drop_count", status.packet_rx_drop_count);
    push_value(L, "flags", status.flags);
    push_value(L, "signature_wait", status.signature_wait);
    // not supported yet: struct __mavlink_signing *signing;
    // not supported yet: struct __mavlink_signing_streams *signing_streams;
    lua_setglobal(L, "link_status");
}

void parse_HEARTBEAT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HEARTBEAT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HEARTBEAT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_heartbeat_t msg_heartbeat;
    mavlink_msg_heartbeat_decode(&msg, & msg_heartbeat);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "type", msg_heartbeat.type);
    push_value(L, "autopilot", msg_heartbeat.autopilot);
    push_value(L, "base_mode", msg_heartbeat.base_mode);
    push_value(L, "custom_mode", msg_heartbeat.custom_mode);
    push_value(L, "system_status", msg_heartbeat.system_status);
    push_value(L, "mavlink_version", msg_heartbeat.mavlink_version);
    lua_setglobal(L, "last_HEARTBEAT");
}

void parse_SYS_STATUS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SYS_STATUS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SYS_STATUS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_sys_status_t msg_sys_status;
    mavlink_msg_sys_status_decode(&msg, & msg_sys_status);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "onboard_control_sensors_present", msg_sys_status.onboard_control_sensors_present);
    push_value(L, "onboard_control_sensors_enabled", msg_sys_status.onboard_control_sensors_enabled);
    push_value(L, "onboard_control_sensors_health", msg_sys_status.onboard_control_sensors_health);
    push_value(L, "load", msg_sys_status.load);
    push_value(L, "voltage_battery", msg_sys_status.voltage_battery);
    push_value(L, "current_battery", msg_sys_status.current_battery);
    push_value(L, "battery_remaining", msg_sys_status.battery_remaining);
    push_value(L, "drop_rate_comm", msg_sys_status.drop_rate_comm);
    push_value(L, "errors_comm", msg_sys_status.errors_comm);
    push_value(L, "errors_count1", msg_sys_status.errors_count1);
    push_value(L, "errors_count2", msg_sys_status.errors_count2);
    push_value(L, "errors_count3", msg_sys_status.errors_count3);
    push_value(L, "errors_count4", msg_sys_status.errors_count4);
    lua_setglobal(L, "last_SYS_STATUS");
}

void parse_SYSTEM_TIME(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SYSTEM_TIME(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SYSTEM_TIME == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_system_time_t msg_system_time;
    mavlink_msg_system_time_decode(&msg, & msg_system_time);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_unix_usec", msg_system_time.time_unix_usec);
    push_value(L, "time_boot_ms", msg_system_time.time_boot_ms);
    lua_setglobal(L, "last_SYSTEM_TIME");
}

void parse_PING(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_PING(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_PING == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_ping_t msg_ping;
    mavlink_msg_ping_decode(&msg, & msg_ping);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_ping.time_usec);
    push_value(L, "seq", msg_ping.seq);
    push_value(L, "target_system", msg_ping.target_system);
    push_value(L, "target_component", msg_ping.target_component);
    lua_setglobal(L, "last_PING");
}

void parse_CHANGE_OPERATOR_CONTROL(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_CHANGE_OPERATOR_CONTROL(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_change_operator_control_t msg_change_operator_control;
    mavlink_msg_change_operator_control_decode(&msg, & msg_change_operator_control);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_change_operator_control.target_system);
    push_value(L, "control_request", msg_change_operator_control.control_request);
    push_value(L, "version", msg_change_operator_control.version);
    push_value(L, "passkey", msg_change_operator_control.passkey);
    lua_setglobal(L, "last_CHANGE_OPERATOR_CONTROL");
}

void parse_CHANGE_OPERATOR_CONTROL_ACK(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_CHANGE_OPERATOR_CONTROL_ACK(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_CHANGE_OPERATOR_CONTROL_ACK == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_change_operator_control_ack_t msg_change_operator_control_ack;
    mavlink_msg_change_operator_control_ack_decode(&msg, & msg_change_operator_control_ack);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "gcs_system_id", msg_change_operator_control_ack.gcs_system_id);
    push_value(L, "control_request", msg_change_operator_control_ack.control_request);
    push_value(L, "ack", msg_change_operator_control_ack.ack);
    lua_setglobal(L, "last_CHANGE_OPERATOR_CONTROL_ACK");
}

void parse_AUTH_KEY(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_AUTH_KEY(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_AUTH_KEY == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_auth_key_t msg_auth_key;
    mavlink_msg_auth_key_decode(&msg, & msg_auth_key);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "key", msg_auth_key.key);
    lua_setglobal(L, "last_AUTH_KEY");
}

void parse_SET_MODE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_MODE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_MODE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_mode_t msg_set_mode;
    mavlink_msg_set_mode_decode(&msg, & msg_set_mode);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_set_mode.target_system);
    push_value(L, "base_mode", msg_set_mode.base_mode);
    push_value(L, "custom_mode", msg_set_mode.custom_mode);
    lua_setglobal(L, "last_SET_MODE");
}

void parse_PARAM_REQUEST_READ(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_PARAM_REQUEST_READ(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_PARAM_REQUEST_READ == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_param_request_read_t msg_param_request_read;
    mavlink_msg_param_request_read_decode(&msg, & msg_param_request_read);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_param_request_read.target_system);
    push_value(L, "target_component", msg_param_request_read.target_component);
    push_value(L, "param_id", msg_param_request_read.param_id);
    push_value(L, "param_index", msg_param_request_read.param_index);
    lua_setglobal(L, "last_PARAM_REQUEST_READ");
}

void parse_PARAM_REQUEST_LIST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_PARAM_REQUEST_LIST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_PARAM_REQUEST_LIST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_param_request_list_t msg_param_request_list;
    mavlink_msg_param_request_list_decode(&msg, & msg_param_request_list);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_param_request_list.target_system);
    push_value(L, "target_component", msg_param_request_list.target_component);
    lua_setglobal(L, "last_PARAM_REQUEST_LIST");
}

void parse_PARAM_VALUE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_PARAM_VALUE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_PARAM_VALUE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_param_value_t msg_param_value;
    mavlink_msg_param_value_decode(&msg, & msg_param_value);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "param_id", msg_param_value.param_id);
    push_value(L, "param_value", msg_param_value.param_value);
    push_value(L, "param_type", msg_param_value.param_type);
    push_value(L, "param_count", msg_param_value.param_count);
    push_value(L, "param_index", msg_param_value.param_index);
    lua_setglobal(L, "last_PARAM_VALUE");
}

void parse_PARAM_SET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_PARAM_SET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_PARAM_SET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_param_set_t msg_param_set;
    mavlink_msg_param_set_decode(&msg, & msg_param_set);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_param_set.target_system);
    push_value(L, "target_component", msg_param_set.target_component);
    push_value(L, "param_id", msg_param_set.param_id);
    push_value(L, "param_value", msg_param_set.param_value);
    push_value(L, "param_type", msg_param_set.param_type);
    lua_setglobal(L, "last_PARAM_SET");
}

void parse_GPS_RAW_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_RAW_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_RAW_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_raw_int_t msg_gps_raw_int;
    mavlink_msg_gps_raw_int_decode(&msg, & msg_gps_raw_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_gps_raw_int.time_usec);
    push_value(L, "fix_type", msg_gps_raw_int.fix_type);
    push_value(L, "lat", msg_gps_raw_int.lat);
    push_value(L, "lon", msg_gps_raw_int.lon);
    push_value(L, "alt", msg_gps_raw_int.alt);
    push_value(L, "eph", msg_gps_raw_int.eph);
    push_value(L, "epv", msg_gps_raw_int.epv);
    push_value(L, "vel", msg_gps_raw_int.vel);
    push_value(L, "cog", msg_gps_raw_int.cog);
    push_value(L, "satellites_visible", msg_gps_raw_int.satellites_visible);
    lua_setglobal(L, "last_GPS_RAW_INT");
}

void parse_GPS_STATUS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_STATUS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_STATUS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_status_t msg_gps_status;
    mavlink_msg_gps_status_decode(&msg, & msg_gps_status);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "satellites_visible", msg_gps_status.satellites_visible);
    lua_pushstring(L, "satellite_prn");
    lua_newtable(L);
    for (int i=0; i<20;i++) {
        push_value(L, i, msg_gps_status.satellite_prn[i]);
    } // end array of 20
    lua_rawset(L, -3);    lua_pushstring(L, "satellite_used");
    lua_newtable(L);
    for (int i=0; i<20;i++) {
        push_value(L, i, msg_gps_status.satellite_used[i]);
    } // end array of 20
    lua_rawset(L, -3);    lua_pushstring(L, "satellite_elevation");
    lua_newtable(L);
    for (int i=0; i<20;i++) {
        push_value(L, i, msg_gps_status.satellite_elevation[i]);
    } // end array of 20
    lua_rawset(L, -3);    lua_pushstring(L, "satellite_azimuth");
    lua_newtable(L);
    for (int i=0; i<20;i++) {
        push_value(L, i, msg_gps_status.satellite_azimuth[i]);
    } // end array of 20
    lua_rawset(L, -3);    lua_pushstring(L, "satellite_snr");
    lua_newtable(L);
    for (int i=0; i<20;i++) {
        push_value(L, i, msg_gps_status.satellite_snr[i]);
    } // end array of 20
    lua_rawset(L, -3);    lua_setglobal(L, "last_GPS_STATUS");
}

void parse_SCALED_IMU(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SCALED_IMU(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SCALED_IMU == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_scaled_imu_t msg_scaled_imu;
    mavlink_msg_scaled_imu_decode(&msg, & msg_scaled_imu);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_scaled_imu.time_boot_ms);
    push_value(L, "xacc", msg_scaled_imu.xacc);
    push_value(L, "yacc", msg_scaled_imu.yacc);
    push_value(L, "zacc", msg_scaled_imu.zacc);
    push_value(L, "xgyro", msg_scaled_imu.xgyro);
    push_value(L, "ygyro", msg_scaled_imu.ygyro);
    push_value(L, "zgyro", msg_scaled_imu.zgyro);
    push_value(L, "xmag", msg_scaled_imu.xmag);
    push_value(L, "ymag", msg_scaled_imu.ymag);
    push_value(L, "zmag", msg_scaled_imu.zmag);
    lua_setglobal(L, "last_SCALED_IMU");
}

void parse_RAW_IMU(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RAW_IMU(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RAW_IMU == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_raw_imu_t msg_raw_imu;
    mavlink_msg_raw_imu_decode(&msg, & msg_raw_imu);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_raw_imu.time_usec);
    push_value(L, "xacc", msg_raw_imu.xacc);
    push_value(L, "yacc", msg_raw_imu.yacc);
    push_value(L, "zacc", msg_raw_imu.zacc);
    push_value(L, "xgyro", msg_raw_imu.xgyro);
    push_value(L, "ygyro", msg_raw_imu.ygyro);
    push_value(L, "zgyro", msg_raw_imu.zgyro);
    push_value(L, "xmag", msg_raw_imu.xmag);
    push_value(L, "ymag", msg_raw_imu.ymag);
    push_value(L, "zmag", msg_raw_imu.zmag);
    lua_setglobal(L, "last_RAW_IMU");
}

void parse_RAW_PRESSURE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RAW_PRESSURE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RAW_PRESSURE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_raw_pressure_t msg_raw_pressure;
    mavlink_msg_raw_pressure_decode(&msg, & msg_raw_pressure);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_raw_pressure.time_usec);
    push_value(L, "press_abs", msg_raw_pressure.press_abs);
    push_value(L, "press_diff1", msg_raw_pressure.press_diff1);
    push_value(L, "press_diff2", msg_raw_pressure.press_diff2);
    push_value(L, "temperature", msg_raw_pressure.temperature);
    lua_setglobal(L, "last_RAW_PRESSURE");
}

void parse_SCALED_PRESSURE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SCALED_PRESSURE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SCALED_PRESSURE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_scaled_pressure_t msg_scaled_pressure;
    mavlink_msg_scaled_pressure_decode(&msg, & msg_scaled_pressure);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_scaled_pressure.time_boot_ms);
    push_value(L, "press_abs", msg_scaled_pressure.press_abs);
    push_value(L, "press_diff", msg_scaled_pressure.press_diff);
    push_value(L, "temperature", msg_scaled_pressure.temperature);
    lua_setglobal(L, "last_SCALED_PRESSURE");
}

void parse_ATTITUDE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ATTITUDE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ATTITUDE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_attitude_t msg_attitude;
    mavlink_msg_attitude_decode(&msg, & msg_attitude);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_attitude.time_boot_ms);
    push_value(L, "roll", msg_attitude.roll);
    push_value(L, "pitch", msg_attitude.pitch);
    push_value(L, "yaw", msg_attitude.yaw);
    push_value(L, "rollspeed", msg_attitude.rollspeed);
    push_value(L, "pitchspeed", msg_attitude.pitchspeed);
    push_value(L, "yawspeed", msg_attitude.yawspeed);
    lua_setglobal(L, "last_ATTITUDE");
}

void parse_ATTITUDE_QUATERNION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ATTITUDE_QUATERNION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ATTITUDE_QUATERNION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_attitude_quaternion_t msg_attitude_quaternion;
    mavlink_msg_attitude_quaternion_decode(&msg, & msg_attitude_quaternion);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_attitude_quaternion.time_boot_ms);
    push_value(L, "q1", msg_attitude_quaternion.q1);
    push_value(L, "q2", msg_attitude_quaternion.q2);
    push_value(L, "q3", msg_attitude_quaternion.q3);
    push_value(L, "q4", msg_attitude_quaternion.q4);
    push_value(L, "rollspeed", msg_attitude_quaternion.rollspeed);
    push_value(L, "pitchspeed", msg_attitude_quaternion.pitchspeed);
    push_value(L, "yawspeed", msg_attitude_quaternion.yawspeed);
    lua_setglobal(L, "last_ATTITUDE_QUATERNION");
}

void parse_LOCAL_POSITION_NED(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOCAL_POSITION_NED(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOCAL_POSITION_NED == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_local_position_ned_t msg_local_position_ned;
    mavlink_msg_local_position_ned_decode(&msg, & msg_local_position_ned);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_local_position_ned.time_boot_ms);
    push_value(L, "x", msg_local_position_ned.x);
    push_value(L, "y", msg_local_position_ned.y);
    push_value(L, "z", msg_local_position_ned.z);
    push_value(L, "vx", msg_local_position_ned.vx);
    push_value(L, "vy", msg_local_position_ned.vy);
    push_value(L, "vz", msg_local_position_ned.vz);
    lua_setglobal(L, "last_LOCAL_POSITION_NED");
}

void parse_GLOBAL_POSITION_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GLOBAL_POSITION_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GLOBAL_POSITION_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_global_position_int_t msg_global_position_int;
    mavlink_msg_global_position_int_decode(&msg, & msg_global_position_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_global_position_int.time_boot_ms);
    push_value(L, "lat", msg_global_position_int.lat);
    push_value(L, "lon", msg_global_position_int.lon);
    push_value(L, "alt", msg_global_position_int.alt);
    push_value(L, "relative_alt", msg_global_position_int.relative_alt);
    push_value(L, "vx", msg_global_position_int.vx);
    push_value(L, "vy", msg_global_position_int.vy);
    push_value(L, "vz", msg_global_position_int.vz);
    push_value(L, "hdg", msg_global_position_int.hdg);
    lua_setglobal(L, "last_GLOBAL_POSITION_INT");
}

void parse_RC_CHANNELS_SCALED(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RC_CHANNELS_SCALED(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RC_CHANNELS_SCALED == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_rc_channels_scaled_t msg_rc_channels_scaled;
    mavlink_msg_rc_channels_scaled_decode(&msg, & msg_rc_channels_scaled);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_rc_channels_scaled.time_boot_ms);
    push_value(L, "port", msg_rc_channels_scaled.port);
    push_value(L, "chan1_scaled", msg_rc_channels_scaled.chan1_scaled);
    push_value(L, "chan2_scaled", msg_rc_channels_scaled.chan2_scaled);
    push_value(L, "chan3_scaled", msg_rc_channels_scaled.chan3_scaled);
    push_value(L, "chan4_scaled", msg_rc_channels_scaled.chan4_scaled);
    push_value(L, "chan5_scaled", msg_rc_channels_scaled.chan5_scaled);
    push_value(L, "chan6_scaled", msg_rc_channels_scaled.chan6_scaled);
    push_value(L, "chan7_scaled", msg_rc_channels_scaled.chan7_scaled);
    push_value(L, "chan8_scaled", msg_rc_channels_scaled.chan8_scaled);
    push_value(L, "rssi", msg_rc_channels_scaled.rssi);
    lua_setglobal(L, "last_RC_CHANNELS_SCALED");
}

void parse_RC_CHANNELS_RAW(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RC_CHANNELS_RAW(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RC_CHANNELS_RAW == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_rc_channels_raw_t msg_rc_channels_raw;
    mavlink_msg_rc_channels_raw_decode(&msg, & msg_rc_channels_raw);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_rc_channels_raw.time_boot_ms);
    push_value(L, "port", msg_rc_channels_raw.port);
    push_value(L, "chan1_raw", msg_rc_channels_raw.chan1_raw);
    push_value(L, "chan2_raw", msg_rc_channels_raw.chan2_raw);
    push_value(L, "chan3_raw", msg_rc_channels_raw.chan3_raw);
    push_value(L, "chan4_raw", msg_rc_channels_raw.chan4_raw);
    push_value(L, "chan5_raw", msg_rc_channels_raw.chan5_raw);
    push_value(L, "chan6_raw", msg_rc_channels_raw.chan6_raw);
    push_value(L, "chan7_raw", msg_rc_channels_raw.chan7_raw);
    push_value(L, "chan8_raw", msg_rc_channels_raw.chan8_raw);
    push_value(L, "rssi", msg_rc_channels_raw.rssi);
    lua_setglobal(L, "last_RC_CHANNELS_RAW");
}

void parse_SERVO_OUTPUT_RAW(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SERVO_OUTPUT_RAW(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SERVO_OUTPUT_RAW == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_servo_output_raw_t msg_servo_output_raw;
    mavlink_msg_servo_output_raw_decode(&msg, & msg_servo_output_raw);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_servo_output_raw.time_usec);
    push_value(L, "port", msg_servo_output_raw.port);
    push_value(L, "servo1_raw", msg_servo_output_raw.servo1_raw);
    push_value(L, "servo2_raw", msg_servo_output_raw.servo2_raw);
    push_value(L, "servo3_raw", msg_servo_output_raw.servo3_raw);
    push_value(L, "servo4_raw", msg_servo_output_raw.servo4_raw);
    push_value(L, "servo5_raw", msg_servo_output_raw.servo5_raw);
    push_value(L, "servo6_raw", msg_servo_output_raw.servo6_raw);
    push_value(L, "servo7_raw", msg_servo_output_raw.servo7_raw);
    push_value(L, "servo8_raw", msg_servo_output_raw.servo8_raw);
    lua_setglobal(L, "last_SERVO_OUTPUT_RAW");
}

void parse_MISSION_REQUEST_PARTIAL_LIST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_REQUEST_PARTIAL_LIST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_REQUEST_PARTIAL_LIST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_request_partial_list_t msg_mission_request_partial_list;
    mavlink_msg_mission_request_partial_list_decode(&msg, & msg_mission_request_partial_list);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_request_partial_list.target_system);
    push_value(L, "target_component", msg_mission_request_partial_list.target_component);
    push_value(L, "start_index", msg_mission_request_partial_list.start_index);
    push_value(L, "end_index", msg_mission_request_partial_list.end_index);
    lua_setglobal(L, "last_MISSION_REQUEST_PARTIAL_LIST");
}

void parse_MISSION_WRITE_PARTIAL_LIST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_WRITE_PARTIAL_LIST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_WRITE_PARTIAL_LIST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_write_partial_list_t msg_mission_write_partial_list;
    mavlink_msg_mission_write_partial_list_decode(&msg, & msg_mission_write_partial_list);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_write_partial_list.target_system);
    push_value(L, "target_component", msg_mission_write_partial_list.target_component);
    push_value(L, "start_index", msg_mission_write_partial_list.start_index);
    push_value(L, "end_index", msg_mission_write_partial_list.end_index);
    lua_setglobal(L, "last_MISSION_WRITE_PARTIAL_LIST");
}

void parse_MISSION_ITEM(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_ITEM(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_ITEM == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_item_t msg_mission_item;
    mavlink_msg_mission_item_decode(&msg, & msg_mission_item);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_item.target_system);
    push_value(L, "target_component", msg_mission_item.target_component);
    push_value(L, "seq", msg_mission_item.seq);
    push_value(L, "frame", msg_mission_item.frame);
    push_value(L, "command", msg_mission_item.command);
    push_value(L, "current", msg_mission_item.current);
    push_value(L, "autocontinue", msg_mission_item.autocontinue);
    push_value(L, "param1", msg_mission_item.param1);
    push_value(L, "param2", msg_mission_item.param2);
    push_value(L, "param3", msg_mission_item.param3);
    push_value(L, "param4", msg_mission_item.param4);
    push_value(L, "x", msg_mission_item.x);
    push_value(L, "y", msg_mission_item.y);
    push_value(L, "z", msg_mission_item.z);
    lua_setglobal(L, "last_MISSION_ITEM");
}

void parse_MISSION_REQUEST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_REQUEST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_REQUEST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_request_t msg_mission_request;
    mavlink_msg_mission_request_decode(&msg, & msg_mission_request);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_request.target_system);
    push_value(L, "target_component", msg_mission_request.target_component);
    push_value(L, "seq", msg_mission_request.seq);
    lua_setglobal(L, "last_MISSION_REQUEST");
}

void parse_MISSION_SET_CURRENT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_SET_CURRENT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_SET_CURRENT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_set_current_t msg_mission_set_current;
    mavlink_msg_mission_set_current_decode(&msg, & msg_mission_set_current);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_set_current.target_system);
    push_value(L, "target_component", msg_mission_set_current.target_component);
    push_value(L, "seq", msg_mission_set_current.seq);
    lua_setglobal(L, "last_MISSION_SET_CURRENT");
}

void parse_MISSION_CURRENT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_CURRENT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_CURRENT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_current_t msg_mission_current;
    mavlink_msg_mission_current_decode(&msg, & msg_mission_current);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "seq", msg_mission_current.seq);
    lua_setglobal(L, "last_MISSION_CURRENT");
}

void parse_MISSION_REQUEST_LIST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_REQUEST_LIST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_REQUEST_LIST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_request_list_t msg_mission_request_list;
    mavlink_msg_mission_request_list_decode(&msg, & msg_mission_request_list);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_request_list.target_system);
    push_value(L, "target_component", msg_mission_request_list.target_component);
    lua_setglobal(L, "last_MISSION_REQUEST_LIST");
}

void parse_MISSION_COUNT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_COUNT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_COUNT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_count_t msg_mission_count;
    mavlink_msg_mission_count_decode(&msg, & msg_mission_count);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_count.target_system);
    push_value(L, "target_component", msg_mission_count.target_component);
    push_value(L, "count", msg_mission_count.count);
    lua_setglobal(L, "last_MISSION_COUNT");
}

void parse_MISSION_CLEAR_ALL(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_CLEAR_ALL(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_CLEAR_ALL == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_clear_all_t msg_mission_clear_all;
    mavlink_msg_mission_clear_all_decode(&msg, & msg_mission_clear_all);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_clear_all.target_system);
    push_value(L, "target_component", msg_mission_clear_all.target_component);
    lua_setglobal(L, "last_MISSION_CLEAR_ALL");
}

void parse_MISSION_ITEM_REACHED(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_ITEM_REACHED(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_ITEM_REACHED == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_item_reached_t msg_mission_item_reached;
    mavlink_msg_mission_item_reached_decode(&msg, & msg_mission_item_reached);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "seq", msg_mission_item_reached.seq);
    lua_setglobal(L, "last_MISSION_ITEM_REACHED");
}

void parse_MISSION_ACK(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_ACK(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_ACK == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_ack_t msg_mission_ack;
    mavlink_msg_mission_ack_decode(&msg, & msg_mission_ack);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_ack.target_system);
    push_value(L, "target_component", msg_mission_ack.target_component);
    push_value(L, "type", msg_mission_ack.type);
    lua_setglobal(L, "last_MISSION_ACK");
}

void parse_SET_GPS_GLOBAL_ORIGIN(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_GPS_GLOBAL_ORIGIN(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_GPS_GLOBAL_ORIGIN == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_gps_global_origin_t msg_set_gps_global_origin;
    mavlink_msg_set_gps_global_origin_decode(&msg, & msg_set_gps_global_origin);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_set_gps_global_origin.target_system);
    push_value(L, "latitude", msg_set_gps_global_origin.latitude);
    push_value(L, "longitude", msg_set_gps_global_origin.longitude);
    push_value(L, "altitude", msg_set_gps_global_origin.altitude);
    lua_setglobal(L, "last_SET_GPS_GLOBAL_ORIGIN");
}

void parse_GPS_GLOBAL_ORIGIN(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_GLOBAL_ORIGIN(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_GLOBAL_ORIGIN == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_global_origin_t msg_gps_global_origin;
    mavlink_msg_gps_global_origin_decode(&msg, & msg_gps_global_origin);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "latitude", msg_gps_global_origin.latitude);
    push_value(L, "longitude", msg_gps_global_origin.longitude);
    push_value(L, "altitude", msg_gps_global_origin.altitude);
    lua_setglobal(L, "last_GPS_GLOBAL_ORIGIN");
}

void parse_PARAM_MAP_RC(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_PARAM_MAP_RC(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_PARAM_MAP_RC == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_param_map_rc_t msg_param_map_rc;
    mavlink_msg_param_map_rc_decode(&msg, & msg_param_map_rc);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_param_map_rc.target_system);
    push_value(L, "target_component", msg_param_map_rc.target_component);
    push_value(L, "param_id", msg_param_map_rc.param_id);
    push_value(L, "param_index", msg_param_map_rc.param_index);
    push_value(L, "parameter_rc_channel_index", msg_param_map_rc.parameter_rc_channel_index);
    push_value(L, "param_value0", msg_param_map_rc.param_value0);
    push_value(L, "scale", msg_param_map_rc.scale);
    push_value(L, "param_value_min", msg_param_map_rc.param_value_min);
    push_value(L, "param_value_max", msg_param_map_rc.param_value_max);
    lua_setglobal(L, "last_PARAM_MAP_RC");
}

void parse_MISSION_REQUEST_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_REQUEST_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_REQUEST_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_request_int_t msg_mission_request_int;
    mavlink_msg_mission_request_int_decode(&msg, & msg_mission_request_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_request_int.target_system);
    push_value(L, "target_component", msg_mission_request_int.target_component);
    push_value(L, "seq", msg_mission_request_int.seq);
    lua_setglobal(L, "last_MISSION_REQUEST_INT");
}

void parse_SAFETY_SET_ALLOWED_AREA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SAFETY_SET_ALLOWED_AREA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SAFETY_SET_ALLOWED_AREA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_safety_set_allowed_area_t msg_safety_set_allowed_area;
    mavlink_msg_safety_set_allowed_area_decode(&msg, & msg_safety_set_allowed_area);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_safety_set_allowed_area.target_system);
    push_value(L, "target_component", msg_safety_set_allowed_area.target_component);
    push_value(L, "frame", msg_safety_set_allowed_area.frame);
    push_value(L, "p1x", msg_safety_set_allowed_area.p1x);
    push_value(L, "p1y", msg_safety_set_allowed_area.p1y);
    push_value(L, "p1z", msg_safety_set_allowed_area.p1z);
    push_value(L, "p2x", msg_safety_set_allowed_area.p2x);
    push_value(L, "p2y", msg_safety_set_allowed_area.p2y);
    push_value(L, "p2z", msg_safety_set_allowed_area.p2z);
    lua_setglobal(L, "last_SAFETY_SET_ALLOWED_AREA");
}

void parse_SAFETY_ALLOWED_AREA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SAFETY_ALLOWED_AREA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SAFETY_ALLOWED_AREA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_safety_allowed_area_t msg_safety_allowed_area;
    mavlink_msg_safety_allowed_area_decode(&msg, & msg_safety_allowed_area);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "frame", msg_safety_allowed_area.frame);
    push_value(L, "p1x", msg_safety_allowed_area.p1x);
    push_value(L, "p1y", msg_safety_allowed_area.p1y);
    push_value(L, "p1z", msg_safety_allowed_area.p1z);
    push_value(L, "p2x", msg_safety_allowed_area.p2x);
    push_value(L, "p2y", msg_safety_allowed_area.p2y);
    push_value(L, "p2z", msg_safety_allowed_area.p2z);
    lua_setglobal(L, "last_SAFETY_ALLOWED_AREA");
}

void parse_ATTITUDE_QUATERNION_COV(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ATTITUDE_QUATERNION_COV(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ATTITUDE_QUATERNION_COV == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_attitude_quaternion_cov_t msg_attitude_quaternion_cov;
    mavlink_msg_attitude_quaternion_cov_decode(&msg, & msg_attitude_quaternion_cov);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_attitude_quaternion_cov.time_usec);
    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_attitude_quaternion_cov.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "rollspeed", msg_attitude_quaternion_cov.rollspeed);
    push_value(L, "pitchspeed", msg_attitude_quaternion_cov.pitchspeed);
    push_value(L, "yawspeed", msg_attitude_quaternion_cov.yawspeed);
    lua_pushstring(L, "covariance");
    lua_newtable(L);
    for (int i=0; i<9;i++) {
        push_value(L, i, msg_attitude_quaternion_cov.covariance[i]);
    } // end array of 9
    lua_rawset(L, -3);    lua_setglobal(L, "last_ATTITUDE_QUATERNION_COV");
}

void parse_NAV_CONTROLLER_OUTPUT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_NAV_CONTROLLER_OUTPUT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_NAV_CONTROLLER_OUTPUT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_nav_controller_output_t msg_nav_controller_output;
    mavlink_msg_nav_controller_output_decode(&msg, & msg_nav_controller_output);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "nav_roll", msg_nav_controller_output.nav_roll);
    push_value(L, "nav_pitch", msg_nav_controller_output.nav_pitch);
    push_value(L, "nav_bearing", msg_nav_controller_output.nav_bearing);
    push_value(L, "target_bearing", msg_nav_controller_output.target_bearing);
    push_value(L, "wp_dist", msg_nav_controller_output.wp_dist);
    push_value(L, "alt_error", msg_nav_controller_output.alt_error);
    push_value(L, "aspd_error", msg_nav_controller_output.aspd_error);
    push_value(L, "xtrack_error", msg_nav_controller_output.xtrack_error);
    lua_setglobal(L, "last_NAV_CONTROLLER_OUTPUT");
}

void parse_GLOBAL_POSITION_INT_COV(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GLOBAL_POSITION_INT_COV(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GLOBAL_POSITION_INT_COV == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_global_position_int_cov_t msg_global_position_int_cov;
    mavlink_msg_global_position_int_cov_decode(&msg, & msg_global_position_int_cov);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_global_position_int_cov.time_usec);
    push_value(L, "estimator_type", msg_global_position_int_cov.estimator_type);
    push_value(L, "lat", msg_global_position_int_cov.lat);
    push_value(L, "lon", msg_global_position_int_cov.lon);
    push_value(L, "alt", msg_global_position_int_cov.alt);
    push_value(L, "relative_alt", msg_global_position_int_cov.relative_alt);
    push_value(L, "vx", msg_global_position_int_cov.vx);
    push_value(L, "vy", msg_global_position_int_cov.vy);
    push_value(L, "vz", msg_global_position_int_cov.vz);
    lua_pushstring(L, "covariance");
    lua_newtable(L);
    for (int i=0; i<36;i++) {
        push_value(L, i, msg_global_position_int_cov.covariance[i]);
    } // end array of 36
    lua_rawset(L, -3);    lua_setglobal(L, "last_GLOBAL_POSITION_INT_COV");
}

void parse_LOCAL_POSITION_NED_COV(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOCAL_POSITION_NED_COV(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOCAL_POSITION_NED_COV == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_local_position_ned_cov_t msg_local_position_ned_cov;
    mavlink_msg_local_position_ned_cov_decode(&msg, & msg_local_position_ned_cov);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_local_position_ned_cov.time_usec);
    push_value(L, "estimator_type", msg_local_position_ned_cov.estimator_type);
    push_value(L, "x", msg_local_position_ned_cov.x);
    push_value(L, "y", msg_local_position_ned_cov.y);
    push_value(L, "z", msg_local_position_ned_cov.z);
    push_value(L, "vx", msg_local_position_ned_cov.vx);
    push_value(L, "vy", msg_local_position_ned_cov.vy);
    push_value(L, "vz", msg_local_position_ned_cov.vz);
    push_value(L, "ax", msg_local_position_ned_cov.ax);
    push_value(L, "ay", msg_local_position_ned_cov.ay);
    push_value(L, "az", msg_local_position_ned_cov.az);
    lua_pushstring(L, "covariance");
    lua_newtable(L);
    for (int i=0; i<45;i++) {
        push_value(L, i, msg_local_position_ned_cov.covariance[i]);
    } // end array of 45
    lua_rawset(L, -3);    lua_setglobal(L, "last_LOCAL_POSITION_NED_COV");
}

void parse_RC_CHANNELS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RC_CHANNELS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RC_CHANNELS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_rc_channels_t msg_rc_channels;
    mavlink_msg_rc_channels_decode(&msg, & msg_rc_channels);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_rc_channels.time_boot_ms);
    push_value(L, "chancount", msg_rc_channels.chancount);
    push_value(L, "chan1_raw", msg_rc_channels.chan1_raw);
    push_value(L, "chan2_raw", msg_rc_channels.chan2_raw);
    push_value(L, "chan3_raw", msg_rc_channels.chan3_raw);
    push_value(L, "chan4_raw", msg_rc_channels.chan4_raw);
    push_value(L, "chan5_raw", msg_rc_channels.chan5_raw);
    push_value(L, "chan6_raw", msg_rc_channels.chan6_raw);
    push_value(L, "chan7_raw", msg_rc_channels.chan7_raw);
    push_value(L, "chan8_raw", msg_rc_channels.chan8_raw);
    push_value(L, "chan9_raw", msg_rc_channels.chan9_raw);
    push_value(L, "chan10_raw", msg_rc_channels.chan10_raw);
    push_value(L, "chan11_raw", msg_rc_channels.chan11_raw);
    push_value(L, "chan12_raw", msg_rc_channels.chan12_raw);
    push_value(L, "chan13_raw", msg_rc_channels.chan13_raw);
    push_value(L, "chan14_raw", msg_rc_channels.chan14_raw);
    push_value(L, "chan15_raw", msg_rc_channels.chan15_raw);
    push_value(L, "chan16_raw", msg_rc_channels.chan16_raw);
    push_value(L, "chan17_raw", msg_rc_channels.chan17_raw);
    push_value(L, "chan18_raw", msg_rc_channels.chan18_raw);
    push_value(L, "rssi", msg_rc_channels.rssi);
    lua_setglobal(L, "last_RC_CHANNELS");
}

void parse_REQUEST_DATA_STREAM(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_REQUEST_DATA_STREAM(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_REQUEST_DATA_STREAM == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_request_data_stream_t msg_request_data_stream;
    mavlink_msg_request_data_stream_decode(&msg, & msg_request_data_stream);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_request_data_stream.target_system);
    push_value(L, "target_component", msg_request_data_stream.target_component);
    push_value(L, "req_stream_id", msg_request_data_stream.req_stream_id);
    push_value(L, "req_message_rate", msg_request_data_stream.req_message_rate);
    push_value(L, "start_stop", msg_request_data_stream.start_stop);
    lua_setglobal(L, "last_REQUEST_DATA_STREAM");
}

void parse_DATA_STREAM(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_DATA_STREAM(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_DATA_STREAM == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_data_stream_t msg_data_stream;
    mavlink_msg_data_stream_decode(&msg, & msg_data_stream);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "stream_id", msg_data_stream.stream_id);
    push_value(L, "message_rate", msg_data_stream.message_rate);
    push_value(L, "on_off", msg_data_stream.on_off);
    lua_setglobal(L, "last_DATA_STREAM");
}

void parse_MANUAL_CONTROL(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MANUAL_CONTROL(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MANUAL_CONTROL == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_manual_control_t msg_manual_control;
    mavlink_msg_manual_control_decode(&msg, & msg_manual_control);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target", msg_manual_control.target);
    push_value(L, "x", msg_manual_control.x);
    push_value(L, "y", msg_manual_control.y);
    push_value(L, "z", msg_manual_control.z);
    push_value(L, "r", msg_manual_control.r);
    push_value(L, "buttons", msg_manual_control.buttons);
    lua_setglobal(L, "last_MANUAL_CONTROL");
}

void parse_RC_CHANNELS_OVERRIDE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RC_CHANNELS_OVERRIDE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_rc_channels_override_t msg_rc_channels_override;
    mavlink_msg_rc_channels_override_decode(&msg, & msg_rc_channels_override);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_rc_channels_override.target_system);
    push_value(L, "target_component", msg_rc_channels_override.target_component);
    push_value(L, "chan1_raw", msg_rc_channels_override.chan1_raw);
    push_value(L, "chan2_raw", msg_rc_channels_override.chan2_raw);
    push_value(L, "chan3_raw", msg_rc_channels_override.chan3_raw);
    push_value(L, "chan4_raw", msg_rc_channels_override.chan4_raw);
    push_value(L, "chan5_raw", msg_rc_channels_override.chan5_raw);
    push_value(L, "chan6_raw", msg_rc_channels_override.chan6_raw);
    push_value(L, "chan7_raw", msg_rc_channels_override.chan7_raw);
    push_value(L, "chan8_raw", msg_rc_channels_override.chan8_raw);
    lua_setglobal(L, "last_RC_CHANNELS_OVERRIDE");
}

void parse_MISSION_ITEM_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MISSION_ITEM_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MISSION_ITEM_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_mission_item_int_t msg_mission_item_int;
    mavlink_msg_mission_item_int_decode(&msg, & msg_mission_item_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_mission_item_int.target_system);
    push_value(L, "target_component", msg_mission_item_int.target_component);
    push_value(L, "seq", msg_mission_item_int.seq);
    push_value(L, "frame", msg_mission_item_int.frame);
    push_value(L, "command", msg_mission_item_int.command);
    push_value(L, "current", msg_mission_item_int.current);
    push_value(L, "autocontinue", msg_mission_item_int.autocontinue);
    push_value(L, "param1", msg_mission_item_int.param1);
    push_value(L, "param2", msg_mission_item_int.param2);
    push_value(L, "param3", msg_mission_item_int.param3);
    push_value(L, "param4", msg_mission_item_int.param4);
    push_value(L, "x", msg_mission_item_int.x);
    push_value(L, "y", msg_mission_item_int.y);
    push_value(L, "z", msg_mission_item_int.z);
    lua_setglobal(L, "last_MISSION_ITEM_INT");
}

void parse_VFR_HUD(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_VFR_HUD(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_VFR_HUD == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_vfr_hud_t msg_vfr_hud;
    mavlink_msg_vfr_hud_decode(&msg, & msg_vfr_hud);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "airspeed", msg_vfr_hud.airspeed);
    push_value(L, "groundspeed", msg_vfr_hud.groundspeed);
    push_value(L, "heading", msg_vfr_hud.heading);
    push_value(L, "throttle", msg_vfr_hud.throttle);
    push_value(L, "alt", msg_vfr_hud.alt);
    push_value(L, "climb", msg_vfr_hud.climb);
    lua_setglobal(L, "last_VFR_HUD");
}

void parse_COMMAND_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_COMMAND_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_COMMAND_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_command_int_t msg_command_int;
    mavlink_msg_command_int_decode(&msg, & msg_command_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_command_int.target_system);
    push_value(L, "target_component", msg_command_int.target_component);
    push_value(L, "frame", msg_command_int.frame);
    push_value(L, "command", msg_command_int.command);
    push_value(L, "current", msg_command_int.current);
    push_value(L, "autocontinue", msg_command_int.autocontinue);
    push_value(L, "param1", msg_command_int.param1);
    push_value(L, "param2", msg_command_int.param2);
    push_value(L, "param3", msg_command_int.param3);
    push_value(L, "param4", msg_command_int.param4);
    push_value(L, "x", msg_command_int.x);
    push_value(L, "y", msg_command_int.y);
    push_value(L, "z", msg_command_int.z);
    lua_setglobal(L, "last_COMMAND_INT");
}

void parse_COMMAND_LONG(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_COMMAND_LONG(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_COMMAND_LONG == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_command_long_t msg_command_long;
    mavlink_msg_command_long_decode(&msg, & msg_command_long);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_command_long.target_system);
    push_value(L, "target_component", msg_command_long.target_component);
    push_value(L, "command", msg_command_long.command);
    push_value(L, "confirmation", msg_command_long.confirmation);
    push_value(L, "param1", msg_command_long.param1);
    push_value(L, "param2", msg_command_long.param2);
    push_value(L, "param3", msg_command_long.param3);
    push_value(L, "param4", msg_command_long.param4);
    push_value(L, "param5", msg_command_long.param5);
    push_value(L, "param6", msg_command_long.param6);
    push_value(L, "param7", msg_command_long.param7);
    lua_setglobal(L, "last_COMMAND_LONG");
}

void parse_COMMAND_ACK(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_COMMAND_ACK(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_COMMAND_ACK == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_command_ack_t msg_command_ack;
    mavlink_msg_command_ack_decode(&msg, & msg_command_ack);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "command", msg_command_ack.command);
    push_value(L, "result", msg_command_ack.result);
    lua_setglobal(L, "last_COMMAND_ACK");
}

void parse_MANUAL_SETPOINT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MANUAL_SETPOINT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MANUAL_SETPOINT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_manual_setpoint_t msg_manual_setpoint;
    mavlink_msg_manual_setpoint_decode(&msg, & msg_manual_setpoint);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_manual_setpoint.time_boot_ms);
    push_value(L, "roll", msg_manual_setpoint.roll);
    push_value(L, "pitch", msg_manual_setpoint.pitch);
    push_value(L, "yaw", msg_manual_setpoint.yaw);
    push_value(L, "thrust", msg_manual_setpoint.thrust);
    push_value(L, "mode_switch", msg_manual_setpoint.mode_switch);
    push_value(L, "manual_override_switch", msg_manual_setpoint.manual_override_switch);
    lua_setglobal(L, "last_MANUAL_SETPOINT");
}

void parse_SET_ATTITUDE_TARGET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_ATTITUDE_TARGET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_ATTITUDE_TARGET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_attitude_target_t msg_set_attitude_target;
    mavlink_msg_set_attitude_target_decode(&msg, & msg_set_attitude_target);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_set_attitude_target.time_boot_ms);
    push_value(L, "target_system", msg_set_attitude_target.target_system);
    push_value(L, "target_component", msg_set_attitude_target.target_component);
    push_value(L, "type_mask", msg_set_attitude_target.type_mask);
    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_set_attitude_target.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "body_roll_rate", msg_set_attitude_target.body_roll_rate);
    push_value(L, "body_pitch_rate", msg_set_attitude_target.body_pitch_rate);
    push_value(L, "body_yaw_rate", msg_set_attitude_target.body_yaw_rate);
    push_value(L, "thrust", msg_set_attitude_target.thrust);
    lua_setglobal(L, "last_SET_ATTITUDE_TARGET");
}

void parse_ATTITUDE_TARGET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ATTITUDE_TARGET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ATTITUDE_TARGET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_attitude_target_t msg_attitude_target;
    mavlink_msg_attitude_target_decode(&msg, & msg_attitude_target);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_attitude_target.time_boot_ms);
    push_value(L, "type_mask", msg_attitude_target.type_mask);
    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_attitude_target.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "body_roll_rate", msg_attitude_target.body_roll_rate);
    push_value(L, "body_pitch_rate", msg_attitude_target.body_pitch_rate);
    push_value(L, "body_yaw_rate", msg_attitude_target.body_yaw_rate);
    push_value(L, "thrust", msg_attitude_target.thrust);
    lua_setglobal(L, "last_ATTITUDE_TARGET");
}

void parse_SET_POSITION_TARGET_LOCAL_NED(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_POSITION_TARGET_LOCAL_NED(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_POSITION_TARGET_LOCAL_NED == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_position_target_local_ned_t msg_set_position_target_local_ned;
    mavlink_msg_set_position_target_local_ned_decode(&msg, & msg_set_position_target_local_ned);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_set_position_target_local_ned.time_boot_ms);
    push_value(L, "target_system", msg_set_position_target_local_ned.target_system);
    push_value(L, "target_component", msg_set_position_target_local_ned.target_component);
    push_value(L, "coordinate_frame", msg_set_position_target_local_ned.coordinate_frame);
    push_value(L, "type_mask", msg_set_position_target_local_ned.type_mask);
    push_value(L, "x", msg_set_position_target_local_ned.x);
    push_value(L, "y", msg_set_position_target_local_ned.y);
    push_value(L, "z", msg_set_position_target_local_ned.z);
    push_value(L, "vx", msg_set_position_target_local_ned.vx);
    push_value(L, "vy", msg_set_position_target_local_ned.vy);
    push_value(L, "vz", msg_set_position_target_local_ned.vz);
    push_value(L, "afx", msg_set_position_target_local_ned.afx);
    push_value(L, "afy", msg_set_position_target_local_ned.afy);
    push_value(L, "afz", msg_set_position_target_local_ned.afz);
    push_value(L, "yaw", msg_set_position_target_local_ned.yaw);
    push_value(L, "yaw_rate", msg_set_position_target_local_ned.yaw_rate);
    lua_setglobal(L, "last_SET_POSITION_TARGET_LOCAL_NED");
}

void parse_POSITION_TARGET_LOCAL_NED(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_POSITION_TARGET_LOCAL_NED(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_POSITION_TARGET_LOCAL_NED == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_position_target_local_ned_t msg_position_target_local_ned;
    mavlink_msg_position_target_local_ned_decode(&msg, & msg_position_target_local_ned);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_position_target_local_ned.time_boot_ms);
    push_value(L, "coordinate_frame", msg_position_target_local_ned.coordinate_frame);
    push_value(L, "type_mask", msg_position_target_local_ned.type_mask);
    push_value(L, "x", msg_position_target_local_ned.x);
    push_value(L, "y", msg_position_target_local_ned.y);
    push_value(L, "z", msg_position_target_local_ned.z);
    push_value(L, "vx", msg_position_target_local_ned.vx);
    push_value(L, "vy", msg_position_target_local_ned.vy);
    push_value(L, "vz", msg_position_target_local_ned.vz);
    push_value(L, "afx", msg_position_target_local_ned.afx);
    push_value(L, "afy", msg_position_target_local_ned.afy);
    push_value(L, "afz", msg_position_target_local_ned.afz);
    push_value(L, "yaw", msg_position_target_local_ned.yaw);
    push_value(L, "yaw_rate", msg_position_target_local_ned.yaw_rate);
    lua_setglobal(L, "last_POSITION_TARGET_LOCAL_NED");
}

void parse_SET_POSITION_TARGET_GLOBAL_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_POSITION_TARGET_GLOBAL_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_POSITION_TARGET_GLOBAL_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_position_target_global_int_t msg_set_position_target_global_int;
    mavlink_msg_set_position_target_global_int_decode(&msg, & msg_set_position_target_global_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_set_position_target_global_int.time_boot_ms);
    push_value(L, "target_system", msg_set_position_target_global_int.target_system);
    push_value(L, "target_component", msg_set_position_target_global_int.target_component);
    push_value(L, "coordinate_frame", msg_set_position_target_global_int.coordinate_frame);
    push_value(L, "type_mask", msg_set_position_target_global_int.type_mask);
    push_value(L, "lat_int", msg_set_position_target_global_int.lat_int);
    push_value(L, "lon_int", msg_set_position_target_global_int.lon_int);
    push_value(L, "alt", msg_set_position_target_global_int.alt);
    push_value(L, "vx", msg_set_position_target_global_int.vx);
    push_value(L, "vy", msg_set_position_target_global_int.vy);
    push_value(L, "vz", msg_set_position_target_global_int.vz);
    push_value(L, "afx", msg_set_position_target_global_int.afx);
    push_value(L, "afy", msg_set_position_target_global_int.afy);
    push_value(L, "afz", msg_set_position_target_global_int.afz);
    push_value(L, "yaw", msg_set_position_target_global_int.yaw);
    push_value(L, "yaw_rate", msg_set_position_target_global_int.yaw_rate);
    lua_setglobal(L, "last_SET_POSITION_TARGET_GLOBAL_INT");
}

void parse_POSITION_TARGET_GLOBAL_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_POSITION_TARGET_GLOBAL_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_POSITION_TARGET_GLOBAL_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_position_target_global_int_t msg_position_target_global_int;
    mavlink_msg_position_target_global_int_decode(&msg, & msg_position_target_global_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_position_target_global_int.time_boot_ms);
    push_value(L, "coordinate_frame", msg_position_target_global_int.coordinate_frame);
    push_value(L, "type_mask", msg_position_target_global_int.type_mask);
    push_value(L, "lat_int", msg_position_target_global_int.lat_int);
    push_value(L, "lon_int", msg_position_target_global_int.lon_int);
    push_value(L, "alt", msg_position_target_global_int.alt);
    push_value(L, "vx", msg_position_target_global_int.vx);
    push_value(L, "vy", msg_position_target_global_int.vy);
    push_value(L, "vz", msg_position_target_global_int.vz);
    push_value(L, "afx", msg_position_target_global_int.afx);
    push_value(L, "afy", msg_position_target_global_int.afy);
    push_value(L, "afz", msg_position_target_global_int.afz);
    push_value(L, "yaw", msg_position_target_global_int.yaw);
    push_value(L, "yaw_rate", msg_position_target_global_int.yaw_rate);
    lua_setglobal(L, "last_POSITION_TARGET_GLOBAL_INT");
}

void parse_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_local_position_ned_system_global_offset_t msg_local_position_ned_system_global_offset;
    mavlink_msg_local_position_ned_system_global_offset_decode(&msg, & msg_local_position_ned_system_global_offset);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_local_position_ned_system_global_offset.time_boot_ms);
    push_value(L, "x", msg_local_position_ned_system_global_offset.x);
    push_value(L, "y", msg_local_position_ned_system_global_offset.y);
    push_value(L, "z", msg_local_position_ned_system_global_offset.z);
    push_value(L, "roll", msg_local_position_ned_system_global_offset.roll);
    push_value(L, "pitch", msg_local_position_ned_system_global_offset.pitch);
    push_value(L, "yaw", msg_local_position_ned_system_global_offset.yaw);
    lua_setglobal(L, "last_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET");
}

void parse_HIL_STATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_STATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_STATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_state_t msg_hil_state;
    mavlink_msg_hil_state_decode(&msg, & msg_hil_state);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_state.time_usec);
    push_value(L, "roll", msg_hil_state.roll);
    push_value(L, "pitch", msg_hil_state.pitch);
    push_value(L, "yaw", msg_hil_state.yaw);
    push_value(L, "rollspeed", msg_hil_state.rollspeed);
    push_value(L, "pitchspeed", msg_hil_state.pitchspeed);
    push_value(L, "yawspeed", msg_hil_state.yawspeed);
    push_value(L, "lat", msg_hil_state.lat);
    push_value(L, "lon", msg_hil_state.lon);
    push_value(L, "alt", msg_hil_state.alt);
    push_value(L, "vx", msg_hil_state.vx);
    push_value(L, "vy", msg_hil_state.vy);
    push_value(L, "vz", msg_hil_state.vz);
    push_value(L, "xacc", msg_hil_state.xacc);
    push_value(L, "yacc", msg_hil_state.yacc);
    push_value(L, "zacc", msg_hil_state.zacc);
    lua_setglobal(L, "last_HIL_STATE");
}

void parse_HIL_CONTROLS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_CONTROLS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_CONTROLS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_controls_t msg_hil_controls;
    mavlink_msg_hil_controls_decode(&msg, & msg_hil_controls);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_controls.time_usec);
    push_value(L, "roll_ailerons", msg_hil_controls.roll_ailerons);
    push_value(L, "pitch_elevator", msg_hil_controls.pitch_elevator);
    push_value(L, "yaw_rudder", msg_hil_controls.yaw_rudder);
    push_value(L, "throttle", msg_hil_controls.throttle);
    push_value(L, "aux1", msg_hil_controls.aux1);
    push_value(L, "aux2", msg_hil_controls.aux2);
    push_value(L, "aux3", msg_hil_controls.aux3);
    push_value(L, "aux4", msg_hil_controls.aux4);
    push_value(L, "mode", msg_hil_controls.mode);
    push_value(L, "nav_mode", msg_hil_controls.nav_mode);
    lua_setglobal(L, "last_HIL_CONTROLS");
}

void parse_HIL_RC_INPUTS_RAW(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_RC_INPUTS_RAW(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_RC_INPUTS_RAW == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_rc_inputs_raw_t msg_hil_rc_inputs_raw;
    mavlink_msg_hil_rc_inputs_raw_decode(&msg, & msg_hil_rc_inputs_raw);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_rc_inputs_raw.time_usec);
    push_value(L, "chan1_raw", msg_hil_rc_inputs_raw.chan1_raw);
    push_value(L, "chan2_raw", msg_hil_rc_inputs_raw.chan2_raw);
    push_value(L, "chan3_raw", msg_hil_rc_inputs_raw.chan3_raw);
    push_value(L, "chan4_raw", msg_hil_rc_inputs_raw.chan4_raw);
    push_value(L, "chan5_raw", msg_hil_rc_inputs_raw.chan5_raw);
    push_value(L, "chan6_raw", msg_hil_rc_inputs_raw.chan6_raw);
    push_value(L, "chan7_raw", msg_hil_rc_inputs_raw.chan7_raw);
    push_value(L, "chan8_raw", msg_hil_rc_inputs_raw.chan8_raw);
    push_value(L, "chan9_raw", msg_hil_rc_inputs_raw.chan9_raw);
    push_value(L, "chan10_raw", msg_hil_rc_inputs_raw.chan10_raw);
    push_value(L, "chan11_raw", msg_hil_rc_inputs_raw.chan11_raw);
    push_value(L, "chan12_raw", msg_hil_rc_inputs_raw.chan12_raw);
    push_value(L, "rssi", msg_hil_rc_inputs_raw.rssi);
    lua_setglobal(L, "last_HIL_RC_INPUTS_RAW");
}

void parse_HIL_ACTUATOR_CONTROLS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_ACTUATOR_CONTROLS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_ACTUATOR_CONTROLS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_actuator_controls_t msg_hil_actuator_controls;
    mavlink_msg_hil_actuator_controls_decode(&msg, & msg_hil_actuator_controls);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_actuator_controls.time_usec);
    lua_pushstring(L, "controls");
    lua_newtable(L);
    for (int i=0; i<16;i++) {
        push_value(L, i, msg_hil_actuator_controls.controls[i]);
    } // end array of 16
    lua_rawset(L, -3);    push_value(L, "mode", msg_hil_actuator_controls.mode);
    push_value(L, "flags", msg_hil_actuator_controls.flags);
    lua_setglobal(L, "last_HIL_ACTUATOR_CONTROLS");
}

void parse_OPTICAL_FLOW(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_OPTICAL_FLOW(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_OPTICAL_FLOW == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_optical_flow_t msg_optical_flow;
    mavlink_msg_optical_flow_decode(&msg, & msg_optical_flow);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_optical_flow.time_usec);
    push_value(L, "sensor_id", msg_optical_flow.sensor_id);
    push_value(L, "flow_x", msg_optical_flow.flow_x);
    push_value(L, "flow_y", msg_optical_flow.flow_y);
    push_value(L, "flow_comp_m_x", msg_optical_flow.flow_comp_m_x);
    push_value(L, "flow_comp_m_y", msg_optical_flow.flow_comp_m_y);
    push_value(L, "quality", msg_optical_flow.quality);
    push_value(L, "ground_distance", msg_optical_flow.ground_distance);
    lua_setglobal(L, "last_OPTICAL_FLOW");
}

void parse_GLOBAL_VISION_POSITION_ESTIMATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GLOBAL_VISION_POSITION_ESTIMATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GLOBAL_VISION_POSITION_ESTIMATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_global_vision_position_estimate_t msg_global_vision_position_estimate;
    mavlink_msg_global_vision_position_estimate_decode(&msg, & msg_global_vision_position_estimate);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "usec", msg_global_vision_position_estimate.usec);
    push_value(L, "x", msg_global_vision_position_estimate.x);
    push_value(L, "y", msg_global_vision_position_estimate.y);
    push_value(L, "z", msg_global_vision_position_estimate.z);
    push_value(L, "roll", msg_global_vision_position_estimate.roll);
    push_value(L, "pitch", msg_global_vision_position_estimate.pitch);
    push_value(L, "yaw", msg_global_vision_position_estimate.yaw);
    lua_setglobal(L, "last_GLOBAL_VISION_POSITION_ESTIMATE");
}

void parse_VISION_POSITION_ESTIMATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_VISION_POSITION_ESTIMATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_VISION_POSITION_ESTIMATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_vision_position_estimate_t msg_vision_position_estimate;
    mavlink_msg_vision_position_estimate_decode(&msg, & msg_vision_position_estimate);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "usec", msg_vision_position_estimate.usec);
    push_value(L, "x", msg_vision_position_estimate.x);
    push_value(L, "y", msg_vision_position_estimate.y);
    push_value(L, "z", msg_vision_position_estimate.z);
    push_value(L, "roll", msg_vision_position_estimate.roll);
    push_value(L, "pitch", msg_vision_position_estimate.pitch);
    push_value(L, "yaw", msg_vision_position_estimate.yaw);
    lua_setglobal(L, "last_VISION_POSITION_ESTIMATE");
}

void parse_VISION_SPEED_ESTIMATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_VISION_SPEED_ESTIMATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_VISION_SPEED_ESTIMATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_vision_speed_estimate_t msg_vision_speed_estimate;
    mavlink_msg_vision_speed_estimate_decode(&msg, & msg_vision_speed_estimate);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "usec", msg_vision_speed_estimate.usec);
    push_value(L, "x", msg_vision_speed_estimate.x);
    push_value(L, "y", msg_vision_speed_estimate.y);
    push_value(L, "z", msg_vision_speed_estimate.z);
    lua_setglobal(L, "last_VISION_SPEED_ESTIMATE");
}

void parse_VICON_POSITION_ESTIMATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_VICON_POSITION_ESTIMATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_VICON_POSITION_ESTIMATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_vicon_position_estimate_t msg_vicon_position_estimate;
    mavlink_msg_vicon_position_estimate_decode(&msg, & msg_vicon_position_estimate);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "usec", msg_vicon_position_estimate.usec);
    push_value(L, "x", msg_vicon_position_estimate.x);
    push_value(L, "y", msg_vicon_position_estimate.y);
    push_value(L, "z", msg_vicon_position_estimate.z);
    push_value(L, "roll", msg_vicon_position_estimate.roll);
    push_value(L, "pitch", msg_vicon_position_estimate.pitch);
    push_value(L, "yaw", msg_vicon_position_estimate.yaw);
    lua_setglobal(L, "last_VICON_POSITION_ESTIMATE");
}

void parse_HIGHRES_IMU(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIGHRES_IMU(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIGHRES_IMU == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_highres_imu_t msg_highres_imu;
    mavlink_msg_highres_imu_decode(&msg, & msg_highres_imu);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_highres_imu.time_usec);
    push_value(L, "xacc", msg_highres_imu.xacc);
    push_value(L, "yacc", msg_highres_imu.yacc);
    push_value(L, "zacc", msg_highres_imu.zacc);
    push_value(L, "xgyro", msg_highres_imu.xgyro);
    push_value(L, "ygyro", msg_highres_imu.ygyro);
    push_value(L, "zgyro", msg_highres_imu.zgyro);
    push_value(L, "xmag", msg_highres_imu.xmag);
    push_value(L, "ymag", msg_highres_imu.ymag);
    push_value(L, "zmag", msg_highres_imu.zmag);
    push_value(L, "abs_pressure", msg_highres_imu.abs_pressure);
    push_value(L, "diff_pressure", msg_highres_imu.diff_pressure);
    push_value(L, "pressure_alt", msg_highres_imu.pressure_alt);
    push_value(L, "temperature", msg_highres_imu.temperature);
    push_value(L, "fields_updated", msg_highres_imu.fields_updated);
    lua_setglobal(L, "last_HIGHRES_IMU");
}

void parse_OPTICAL_FLOW_RAD(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_OPTICAL_FLOW_RAD(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_OPTICAL_FLOW_RAD == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_optical_flow_rad_t msg_optical_flow_rad;
    mavlink_msg_optical_flow_rad_decode(&msg, & msg_optical_flow_rad);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_optical_flow_rad.time_usec);
    push_value(L, "sensor_id", msg_optical_flow_rad.sensor_id);
    push_value(L, "integration_time_us", msg_optical_flow_rad.integration_time_us);
    push_value(L, "integrated_x", msg_optical_flow_rad.integrated_x);
    push_value(L, "integrated_y", msg_optical_flow_rad.integrated_y);
    push_value(L, "integrated_xgyro", msg_optical_flow_rad.integrated_xgyro);
    push_value(L, "integrated_ygyro", msg_optical_flow_rad.integrated_ygyro);
    push_value(L, "integrated_zgyro", msg_optical_flow_rad.integrated_zgyro);
    push_value(L, "temperature", msg_optical_flow_rad.temperature);
    push_value(L, "quality", msg_optical_flow_rad.quality);
    push_value(L, "time_delta_distance_us", msg_optical_flow_rad.time_delta_distance_us);
    push_value(L, "distance", msg_optical_flow_rad.distance);
    lua_setglobal(L, "last_OPTICAL_FLOW_RAD");
}

void parse_HIL_SENSOR(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_SENSOR(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_SENSOR == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_sensor_t msg_hil_sensor;
    mavlink_msg_hil_sensor_decode(&msg, & msg_hil_sensor);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_sensor.time_usec);
    push_value(L, "xacc", msg_hil_sensor.xacc);
    push_value(L, "yacc", msg_hil_sensor.yacc);
    push_value(L, "zacc", msg_hil_sensor.zacc);
    push_value(L, "xgyro", msg_hil_sensor.xgyro);
    push_value(L, "ygyro", msg_hil_sensor.ygyro);
    push_value(L, "zgyro", msg_hil_sensor.zgyro);
    push_value(L, "xmag", msg_hil_sensor.xmag);
    push_value(L, "ymag", msg_hil_sensor.ymag);
    push_value(L, "zmag", msg_hil_sensor.zmag);
    push_value(L, "abs_pressure", msg_hil_sensor.abs_pressure);
    push_value(L, "diff_pressure", msg_hil_sensor.diff_pressure);
    push_value(L, "pressure_alt", msg_hil_sensor.pressure_alt);
    push_value(L, "temperature", msg_hil_sensor.temperature);
    push_value(L, "fields_updated", msg_hil_sensor.fields_updated);
    lua_setglobal(L, "last_HIL_SENSOR");
}

void parse_SIM_STATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SIM_STATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SIM_STATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_sim_state_t msg_sim_state;
    mavlink_msg_sim_state_decode(&msg, & msg_sim_state);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "q1", msg_sim_state.q1);
    push_value(L, "q2", msg_sim_state.q2);
    push_value(L, "q3", msg_sim_state.q3);
    push_value(L, "q4", msg_sim_state.q4);
    push_value(L, "roll", msg_sim_state.roll);
    push_value(L, "pitch", msg_sim_state.pitch);
    push_value(L, "yaw", msg_sim_state.yaw);
    push_value(L, "xacc", msg_sim_state.xacc);
    push_value(L, "yacc", msg_sim_state.yacc);
    push_value(L, "zacc", msg_sim_state.zacc);
    push_value(L, "xgyro", msg_sim_state.xgyro);
    push_value(L, "ygyro", msg_sim_state.ygyro);
    push_value(L, "zgyro", msg_sim_state.zgyro);
    push_value(L, "lat", msg_sim_state.lat);
    push_value(L, "lon", msg_sim_state.lon);
    push_value(L, "alt", msg_sim_state.alt);
    push_value(L, "std_dev_horz", msg_sim_state.std_dev_horz);
    push_value(L, "std_dev_vert", msg_sim_state.std_dev_vert);
    push_value(L, "vn", msg_sim_state.vn);
    push_value(L, "ve", msg_sim_state.ve);
    push_value(L, "vd", msg_sim_state.vd);
    lua_setglobal(L, "last_SIM_STATE");
}

void parse_RADIO_STATUS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RADIO_STATUS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RADIO_STATUS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_radio_status_t msg_radio_status;
    mavlink_msg_radio_status_decode(&msg, & msg_radio_status);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "rssi", msg_radio_status.rssi);
    push_value(L, "remrssi", msg_radio_status.remrssi);
    push_value(L, "txbuf", msg_radio_status.txbuf);
    push_value(L, "noise", msg_radio_status.noise);
    push_value(L, "remnoise", msg_radio_status.remnoise);
    push_value(L, "rxerrors", msg_radio_status.rxerrors);
    push_value(L, "fixed", msg_radio_status.fixed);
    lua_setglobal(L, "last_RADIO_STATUS");
}

void parse_FILE_TRANSFER_PROTOCOL(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_FILE_TRANSFER_PROTOCOL(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_FILE_TRANSFER_PROTOCOL == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_file_transfer_protocol_t msg_file_transfer_protocol;
    mavlink_msg_file_transfer_protocol_decode(&msg, & msg_file_transfer_protocol);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_network", msg_file_transfer_protocol.target_network);
    push_value(L, "target_system", msg_file_transfer_protocol.target_system);
    push_value(L, "target_component", msg_file_transfer_protocol.target_component);
    lua_pushstring(L, "payload");
    lua_newtable(L);
    for (int i=0; i<251;i++) {
        push_value(L, i, msg_file_transfer_protocol.payload[i]);
    } // end array of 251
    lua_rawset(L, -3);    lua_setglobal(L, "last_FILE_TRANSFER_PROTOCOL");
}

void parse_TIMESYNC(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_TIMESYNC(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_TIMESYNC == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_timesync_t msg_timesync;
    mavlink_msg_timesync_decode(&msg, & msg_timesync);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "tc1", msg_timesync.tc1);
    push_value(L, "ts1", msg_timesync.ts1);
    lua_setglobal(L, "last_TIMESYNC");
}

void parse_CAMERA_TRIGGER(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_CAMERA_TRIGGER(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_CAMERA_TRIGGER == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_camera_trigger_t msg_camera_trigger;
    mavlink_msg_camera_trigger_decode(&msg, & msg_camera_trigger);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_camera_trigger.time_usec);
    push_value(L, "seq", msg_camera_trigger.seq);
    lua_setglobal(L, "last_CAMERA_TRIGGER");
}

void parse_HIL_GPS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_GPS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_GPS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_gps_t msg_hil_gps;
    mavlink_msg_hil_gps_decode(&msg, & msg_hil_gps);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_gps.time_usec);
    push_value(L, "fix_type", msg_hil_gps.fix_type);
    push_value(L, "lat", msg_hil_gps.lat);
    push_value(L, "lon", msg_hil_gps.lon);
    push_value(L, "alt", msg_hil_gps.alt);
    push_value(L, "eph", msg_hil_gps.eph);
    push_value(L, "epv", msg_hil_gps.epv);
    push_value(L, "vel", msg_hil_gps.vel);
    push_value(L, "vn", msg_hil_gps.vn);
    push_value(L, "ve", msg_hil_gps.ve);
    push_value(L, "vd", msg_hil_gps.vd);
    push_value(L, "cog", msg_hil_gps.cog);
    push_value(L, "satellites_visible", msg_hil_gps.satellites_visible);
    lua_setglobal(L, "last_HIL_GPS");
}

void parse_HIL_OPTICAL_FLOW(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_OPTICAL_FLOW(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_OPTICAL_FLOW == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_optical_flow_t msg_hil_optical_flow;
    mavlink_msg_hil_optical_flow_decode(&msg, & msg_hil_optical_flow);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_optical_flow.time_usec);
    push_value(L, "sensor_id", msg_hil_optical_flow.sensor_id);
    push_value(L, "integration_time_us", msg_hil_optical_flow.integration_time_us);
    push_value(L, "integrated_x", msg_hil_optical_flow.integrated_x);
    push_value(L, "integrated_y", msg_hil_optical_flow.integrated_y);
    push_value(L, "integrated_xgyro", msg_hil_optical_flow.integrated_xgyro);
    push_value(L, "integrated_ygyro", msg_hil_optical_flow.integrated_ygyro);
    push_value(L, "integrated_zgyro", msg_hil_optical_flow.integrated_zgyro);
    push_value(L, "temperature", msg_hil_optical_flow.temperature);
    push_value(L, "quality", msg_hil_optical_flow.quality);
    push_value(L, "time_delta_distance_us", msg_hil_optical_flow.time_delta_distance_us);
    push_value(L, "distance", msg_hil_optical_flow.distance);
    lua_setglobal(L, "last_HIL_OPTICAL_FLOW");
}

void parse_HIL_STATE_QUATERNION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIL_STATE_QUATERNION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIL_STATE_QUATERNION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_hil_state_quaternion_t msg_hil_state_quaternion;
    mavlink_msg_hil_state_quaternion_decode(&msg, & msg_hil_state_quaternion);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_hil_state_quaternion.time_usec);
    lua_pushstring(L, "attitude_quaternion");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_hil_state_quaternion.attitude_quaternion[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "rollspeed", msg_hil_state_quaternion.rollspeed);
    push_value(L, "pitchspeed", msg_hil_state_quaternion.pitchspeed);
    push_value(L, "yawspeed", msg_hil_state_quaternion.yawspeed);
    push_value(L, "lat", msg_hil_state_quaternion.lat);
    push_value(L, "lon", msg_hil_state_quaternion.lon);
    push_value(L, "alt", msg_hil_state_quaternion.alt);
    push_value(L, "vx", msg_hil_state_quaternion.vx);
    push_value(L, "vy", msg_hil_state_quaternion.vy);
    push_value(L, "vz", msg_hil_state_quaternion.vz);
    push_value(L, "ind_airspeed", msg_hil_state_quaternion.ind_airspeed);
    push_value(L, "true_airspeed", msg_hil_state_quaternion.true_airspeed);
    push_value(L, "xacc", msg_hil_state_quaternion.xacc);
    push_value(L, "yacc", msg_hil_state_quaternion.yacc);
    push_value(L, "zacc", msg_hil_state_quaternion.zacc);
    lua_setglobal(L, "last_HIL_STATE_QUATERNION");
}

void parse_SCALED_IMU2(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SCALED_IMU2(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SCALED_IMU2 == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_scaled_imu2_t msg_scaled_imu2;
    mavlink_msg_scaled_imu2_decode(&msg, & msg_scaled_imu2);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_scaled_imu2.time_boot_ms);
    push_value(L, "xacc", msg_scaled_imu2.xacc);
    push_value(L, "yacc", msg_scaled_imu2.yacc);
    push_value(L, "zacc", msg_scaled_imu2.zacc);
    push_value(L, "xgyro", msg_scaled_imu2.xgyro);
    push_value(L, "ygyro", msg_scaled_imu2.ygyro);
    push_value(L, "zgyro", msg_scaled_imu2.zgyro);
    push_value(L, "xmag", msg_scaled_imu2.xmag);
    push_value(L, "ymag", msg_scaled_imu2.ymag);
    push_value(L, "zmag", msg_scaled_imu2.zmag);
    lua_setglobal(L, "last_SCALED_IMU2");
}

void parse_LOG_REQUEST_LIST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOG_REQUEST_LIST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOG_REQUEST_LIST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_log_request_list_t msg_log_request_list;
    mavlink_msg_log_request_list_decode(&msg, & msg_log_request_list);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_log_request_list.target_system);
    push_value(L, "target_component", msg_log_request_list.target_component);
    push_value(L, "start", msg_log_request_list.start);
    push_value(L, "end", msg_log_request_list.end);
    lua_setglobal(L, "last_LOG_REQUEST_LIST");
}

void parse_LOG_ENTRY(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOG_ENTRY(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOG_ENTRY == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_log_entry_t msg_log_entry;
    mavlink_msg_log_entry_decode(&msg, & msg_log_entry);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "id", msg_log_entry.id);
    push_value(L, "num_logs", msg_log_entry.num_logs);
    push_value(L, "last_log_num", msg_log_entry.last_log_num);
    push_value(L, "time_utc", msg_log_entry.time_utc);
    push_value(L, "size", msg_log_entry.size);
    lua_setglobal(L, "last_LOG_ENTRY");
}

void parse_LOG_REQUEST_DATA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOG_REQUEST_DATA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOG_REQUEST_DATA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_log_request_data_t msg_log_request_data;
    mavlink_msg_log_request_data_decode(&msg, & msg_log_request_data);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_log_request_data.target_system);
    push_value(L, "target_component", msg_log_request_data.target_component);
    push_value(L, "id", msg_log_request_data.id);
    push_value(L, "ofs", msg_log_request_data.ofs);
    push_value(L, "count", msg_log_request_data.count);
    lua_setglobal(L, "last_LOG_REQUEST_DATA");
}

void parse_LOG_DATA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOG_DATA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOG_DATA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_log_data_t msg_log_data;
    mavlink_msg_log_data_decode(&msg, & msg_log_data);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "id", msg_log_data.id);
    push_value(L, "ofs", msg_log_data.ofs);
    push_value(L, "count", msg_log_data.count);
    lua_pushstring(L, "data");
    lua_newtable(L);
    for (int i=0; i<90;i++) {
        push_value(L, i, msg_log_data.data[i]);
    } // end array of 90
    lua_rawset(L, -3);    lua_setglobal(L, "last_LOG_DATA");
}

void parse_LOG_ERASE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOG_ERASE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOG_ERASE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_log_erase_t msg_log_erase;
    mavlink_msg_log_erase_decode(&msg, & msg_log_erase);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_log_erase.target_system);
    push_value(L, "target_component", msg_log_erase.target_component);
    lua_setglobal(L, "last_LOG_ERASE");
}

void parse_LOG_REQUEST_END(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LOG_REQUEST_END(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LOG_REQUEST_END == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_log_request_end_t msg_log_request_end;
    mavlink_msg_log_request_end_decode(&msg, & msg_log_request_end);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_log_request_end.target_system);
    push_value(L, "target_component", msg_log_request_end.target_component);
    lua_setglobal(L, "last_LOG_REQUEST_END");
}

void parse_GPS_INJECT_DATA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_INJECT_DATA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_INJECT_DATA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_inject_data_t msg_gps_inject_data;
    mavlink_msg_gps_inject_data_decode(&msg, & msg_gps_inject_data);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_gps_inject_data.target_system);
    push_value(L, "target_component", msg_gps_inject_data.target_component);
    push_value(L, "len", msg_gps_inject_data.len);
    lua_pushstring(L, "data");
    lua_newtable(L);
    for (int i=0; i<110;i++) {
        push_value(L, i, msg_gps_inject_data.data[i]);
    } // end array of 110
    lua_rawset(L, -3);    lua_setglobal(L, "last_GPS_INJECT_DATA");
}

void parse_GPS2_RAW(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS2_RAW(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS2_RAW == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps2_raw_t msg_gps2_raw;
    mavlink_msg_gps2_raw_decode(&msg, & msg_gps2_raw);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_gps2_raw.time_usec);
    push_value(L, "fix_type", msg_gps2_raw.fix_type);
    push_value(L, "lat", msg_gps2_raw.lat);
    push_value(L, "lon", msg_gps2_raw.lon);
    push_value(L, "alt", msg_gps2_raw.alt);
    push_value(L, "eph", msg_gps2_raw.eph);
    push_value(L, "epv", msg_gps2_raw.epv);
    push_value(L, "vel", msg_gps2_raw.vel);
    push_value(L, "cog", msg_gps2_raw.cog);
    push_value(L, "satellites_visible", msg_gps2_raw.satellites_visible);
    push_value(L, "dgps_numch", msg_gps2_raw.dgps_numch);
    push_value(L, "dgps_age", msg_gps2_raw.dgps_age);
    lua_setglobal(L, "last_GPS2_RAW");
}

void parse_POWER_STATUS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_POWER_STATUS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_POWER_STATUS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_power_status_t msg_power_status;
    mavlink_msg_power_status_decode(&msg, & msg_power_status);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "Vcc", msg_power_status.Vcc);
    push_value(L, "Vservo", msg_power_status.Vservo);
    push_value(L, "flags", msg_power_status.flags);
    lua_setglobal(L, "last_POWER_STATUS");
}

void parse_SERIAL_CONTROL(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SERIAL_CONTROL(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SERIAL_CONTROL == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_serial_control_t msg_serial_control;
    mavlink_msg_serial_control_decode(&msg, & msg_serial_control);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "device", msg_serial_control.device);
    push_value(L, "flags", msg_serial_control.flags);
    push_value(L, "timeout", msg_serial_control.timeout);
    push_value(L, "baudrate", msg_serial_control.baudrate);
    push_value(L, "count", msg_serial_control.count);
    lua_pushstring(L, "data");
    lua_newtable(L);
    for (int i=0; i<70;i++) {
        push_value(L, i, msg_serial_control.data[i]);
    } // end array of 70
    lua_rawset(L, -3);    lua_setglobal(L, "last_SERIAL_CONTROL");
}

void parse_GPS_RTK(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_RTK(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_RTK == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_rtk_t msg_gps_rtk;
    mavlink_msg_gps_rtk_decode(&msg, & msg_gps_rtk);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_last_baseline_ms", msg_gps_rtk.time_last_baseline_ms);
    push_value(L, "rtk_receiver_id", msg_gps_rtk.rtk_receiver_id);
    push_value(L, "wn", msg_gps_rtk.wn);
    push_value(L, "tow", msg_gps_rtk.tow);
    push_value(L, "rtk_health", msg_gps_rtk.rtk_health);
    push_value(L, "rtk_rate", msg_gps_rtk.rtk_rate);
    push_value(L, "nsats", msg_gps_rtk.nsats);
    push_value(L, "baseline_coords_type", msg_gps_rtk.baseline_coords_type);
    push_value(L, "baseline_a_mm", msg_gps_rtk.baseline_a_mm);
    push_value(L, "baseline_b_mm", msg_gps_rtk.baseline_b_mm);
    push_value(L, "baseline_c_mm", msg_gps_rtk.baseline_c_mm);
    push_value(L, "accuracy", msg_gps_rtk.accuracy);
    push_value(L, "iar_num_hypotheses", msg_gps_rtk.iar_num_hypotheses);
    lua_setglobal(L, "last_GPS_RTK");
}

void parse_GPS2_RTK(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS2_RTK(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS2_RTK == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps2_rtk_t msg_gps2_rtk;
    mavlink_msg_gps2_rtk_decode(&msg, & msg_gps2_rtk);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_last_baseline_ms", msg_gps2_rtk.time_last_baseline_ms);
    push_value(L, "rtk_receiver_id", msg_gps2_rtk.rtk_receiver_id);
    push_value(L, "wn", msg_gps2_rtk.wn);
    push_value(L, "tow", msg_gps2_rtk.tow);
    push_value(L, "rtk_health", msg_gps2_rtk.rtk_health);
    push_value(L, "rtk_rate", msg_gps2_rtk.rtk_rate);
    push_value(L, "nsats", msg_gps2_rtk.nsats);
    push_value(L, "baseline_coords_type", msg_gps2_rtk.baseline_coords_type);
    push_value(L, "baseline_a_mm", msg_gps2_rtk.baseline_a_mm);
    push_value(L, "baseline_b_mm", msg_gps2_rtk.baseline_b_mm);
    push_value(L, "baseline_c_mm", msg_gps2_rtk.baseline_c_mm);
    push_value(L, "accuracy", msg_gps2_rtk.accuracy);
    push_value(L, "iar_num_hypotheses", msg_gps2_rtk.iar_num_hypotheses);
    lua_setglobal(L, "last_GPS2_RTK");
}

void parse_SCALED_IMU3(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SCALED_IMU3(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SCALED_IMU3 == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_scaled_imu3_t msg_scaled_imu3;
    mavlink_msg_scaled_imu3_decode(&msg, & msg_scaled_imu3);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_scaled_imu3.time_boot_ms);
    push_value(L, "xacc", msg_scaled_imu3.xacc);
    push_value(L, "yacc", msg_scaled_imu3.yacc);
    push_value(L, "zacc", msg_scaled_imu3.zacc);
    push_value(L, "xgyro", msg_scaled_imu3.xgyro);
    push_value(L, "ygyro", msg_scaled_imu3.ygyro);
    push_value(L, "zgyro", msg_scaled_imu3.zgyro);
    push_value(L, "xmag", msg_scaled_imu3.xmag);
    push_value(L, "ymag", msg_scaled_imu3.ymag);
    push_value(L, "zmag", msg_scaled_imu3.zmag);
    lua_setglobal(L, "last_SCALED_IMU3");
}

void parse_DATA_TRANSMISSION_HANDSHAKE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_DATA_TRANSMISSION_HANDSHAKE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_DATA_TRANSMISSION_HANDSHAKE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_data_transmission_handshake_t msg_data_transmission_handshake;
    mavlink_msg_data_transmission_handshake_decode(&msg, & msg_data_transmission_handshake);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "type", msg_data_transmission_handshake.type);
    push_value(L, "size", msg_data_transmission_handshake.size);
    push_value(L, "width", msg_data_transmission_handshake.width);
    push_value(L, "height", msg_data_transmission_handshake.height);
    push_value(L, "packets", msg_data_transmission_handshake.packets);
    push_value(L, "payload", msg_data_transmission_handshake.payload);
    push_value(L, "jpg_quality", msg_data_transmission_handshake.jpg_quality);
    lua_setglobal(L, "last_DATA_TRANSMISSION_HANDSHAKE");
}

void parse_ENCAPSULATED_DATA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ENCAPSULATED_DATA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ENCAPSULATED_DATA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_encapsulated_data_t msg_encapsulated_data;
    mavlink_msg_encapsulated_data_decode(&msg, & msg_encapsulated_data);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "seqnr", msg_encapsulated_data.seqnr);
    lua_pushstring(L, "data");
    lua_newtable(L);
    for (int i=0; i<253;i++) {
        push_value(L, i, msg_encapsulated_data.data[i]);
    } // end array of 253
    lua_rawset(L, -3);    lua_setglobal(L, "last_ENCAPSULATED_DATA");
}

void parse_DISTANCE_SENSOR(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_DISTANCE_SENSOR(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_DISTANCE_SENSOR == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_distance_sensor_t msg_distance_sensor;
    mavlink_msg_distance_sensor_decode(&msg, & msg_distance_sensor);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_distance_sensor.time_boot_ms);
    push_value(L, "min_distance", msg_distance_sensor.min_distance);
    push_value(L, "max_distance", msg_distance_sensor.max_distance);
    push_value(L, "current_distance", msg_distance_sensor.current_distance);
    push_value(L, "type", msg_distance_sensor.type);
    push_value(L, "id", msg_distance_sensor.id);
    push_value(L, "orientation", msg_distance_sensor.orientation);
    push_value(L, "covariance", msg_distance_sensor.covariance);
    lua_setglobal(L, "last_DISTANCE_SENSOR");
}

void parse_TERRAIN_REQUEST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_TERRAIN_REQUEST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_TERRAIN_REQUEST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_terrain_request_t msg_terrain_request;
    mavlink_msg_terrain_request_decode(&msg, & msg_terrain_request);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "lat", msg_terrain_request.lat);
    push_value(L, "lon", msg_terrain_request.lon);
    push_value(L, "grid_spacing", msg_terrain_request.grid_spacing);
    push_value(L, "mask", msg_terrain_request.mask);
    lua_setglobal(L, "last_TERRAIN_REQUEST");
}

void parse_TERRAIN_DATA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_TERRAIN_DATA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_TERRAIN_DATA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_terrain_data_t msg_terrain_data;
    mavlink_msg_terrain_data_decode(&msg, & msg_terrain_data);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "lat", msg_terrain_data.lat);
    push_value(L, "lon", msg_terrain_data.lon);
    push_value(L, "grid_spacing", msg_terrain_data.grid_spacing);
    push_value(L, "gridbit", msg_terrain_data.gridbit);
    lua_pushstring(L, "data");
    lua_newtable(L);
    for (int i=0; i<16;i++) {
        push_value(L, i, msg_terrain_data.data[i]);
    } // end array of 16
    lua_rawset(L, -3);    lua_setglobal(L, "last_TERRAIN_DATA");
}

void parse_TERRAIN_CHECK(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_TERRAIN_CHECK(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_TERRAIN_CHECK == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_terrain_check_t msg_terrain_check;
    mavlink_msg_terrain_check_decode(&msg, & msg_terrain_check);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "lat", msg_terrain_check.lat);
    push_value(L, "lon", msg_terrain_check.lon);
    lua_setglobal(L, "last_TERRAIN_CHECK");
}

void parse_TERRAIN_REPORT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_TERRAIN_REPORT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_TERRAIN_REPORT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_terrain_report_t msg_terrain_report;
    mavlink_msg_terrain_report_decode(&msg, & msg_terrain_report);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "lat", msg_terrain_report.lat);
    push_value(L, "lon", msg_terrain_report.lon);
    push_value(L, "spacing", msg_terrain_report.spacing);
    push_value(L, "terrain_height", msg_terrain_report.terrain_height);
    push_value(L, "current_height", msg_terrain_report.current_height);
    push_value(L, "pending", msg_terrain_report.pending);
    push_value(L, "loaded", msg_terrain_report.loaded);
    lua_setglobal(L, "last_TERRAIN_REPORT");
}

void parse_SCALED_PRESSURE2(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SCALED_PRESSURE2(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SCALED_PRESSURE2 == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_scaled_pressure2_t msg_scaled_pressure2;
    mavlink_msg_scaled_pressure2_decode(&msg, & msg_scaled_pressure2);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_scaled_pressure2.time_boot_ms);
    push_value(L, "press_abs", msg_scaled_pressure2.press_abs);
    push_value(L, "press_diff", msg_scaled_pressure2.press_diff);
    push_value(L, "temperature", msg_scaled_pressure2.temperature);
    lua_setglobal(L, "last_SCALED_PRESSURE2");
}

void parse_ATT_POS_MOCAP(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ATT_POS_MOCAP(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ATT_POS_MOCAP == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_att_pos_mocap_t msg_att_pos_mocap;
    mavlink_msg_att_pos_mocap_decode(&msg, & msg_att_pos_mocap);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_att_pos_mocap.time_usec);
    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_att_pos_mocap.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "x", msg_att_pos_mocap.x);
    push_value(L, "y", msg_att_pos_mocap.y);
    push_value(L, "z", msg_att_pos_mocap.z);
    lua_setglobal(L, "last_ATT_POS_MOCAP");
}

void parse_SET_ACTUATOR_CONTROL_TARGET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_ACTUATOR_CONTROL_TARGET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_ACTUATOR_CONTROL_TARGET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_actuator_control_target_t msg_set_actuator_control_target;
    mavlink_msg_set_actuator_control_target_decode(&msg, & msg_set_actuator_control_target);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_set_actuator_control_target.time_usec);
    push_value(L, "group_mlx", msg_set_actuator_control_target.group_mlx);
    push_value(L, "target_system", msg_set_actuator_control_target.target_system);
    push_value(L, "target_component", msg_set_actuator_control_target.target_component);
    lua_pushstring(L, "controls");
    lua_newtable(L);
    for (int i=0; i<8;i++) {
        push_value(L, i, msg_set_actuator_control_target.controls[i]);
    } // end array of 8
    lua_rawset(L, -3);    lua_setglobal(L, "last_SET_ACTUATOR_CONTROL_TARGET");
}

void parse_ACTUATOR_CONTROL_TARGET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ACTUATOR_CONTROL_TARGET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ACTUATOR_CONTROL_TARGET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_actuator_control_target_t msg_actuator_control_target;
    mavlink_msg_actuator_control_target_decode(&msg, & msg_actuator_control_target);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_actuator_control_target.time_usec);
    push_value(L, "group_mlx", msg_actuator_control_target.group_mlx);
    lua_pushstring(L, "controls");
    lua_newtable(L);
    for (int i=0; i<8;i++) {
        push_value(L, i, msg_actuator_control_target.controls[i]);
    } // end array of 8
    lua_rawset(L, -3);    lua_setglobal(L, "last_ACTUATOR_CONTROL_TARGET");
}

void parse_ALTITUDE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ALTITUDE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ALTITUDE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_altitude_t msg_altitude;
    mavlink_msg_altitude_decode(&msg, & msg_altitude);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_altitude.time_usec);
    push_value(L, "altitude_monotonic", msg_altitude.altitude_monotonic);
    push_value(L, "altitude_amsl", msg_altitude.altitude_amsl);
    push_value(L, "altitude_local", msg_altitude.altitude_local);
    push_value(L, "altitude_relative", msg_altitude.altitude_relative);
    push_value(L, "altitude_terrain", msg_altitude.altitude_terrain);
    push_value(L, "bottom_clearance", msg_altitude.bottom_clearance);
    lua_setglobal(L, "last_ALTITUDE");
}

void parse_RESOURCE_REQUEST(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_RESOURCE_REQUEST(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_RESOURCE_REQUEST == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_resource_request_t msg_resource_request;
    mavlink_msg_resource_request_decode(&msg, & msg_resource_request);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "request_id", msg_resource_request.request_id);
    push_value(L, "uri_type", msg_resource_request.uri_type);
    lua_pushstring(L, "uri");
    lua_newtable(L);
    for (int i=0; i<120;i++) {
        push_value(L, i, msg_resource_request.uri[i]);
    } // end array of 120
    lua_rawset(L, -3);    push_value(L, "transfer_type", msg_resource_request.transfer_type);
    lua_pushstring(L, "storage");
    lua_newtable(L);
    for (int i=0; i<120;i++) {
        push_value(L, i, msg_resource_request.storage[i]);
    } // end array of 120
    lua_rawset(L, -3);    lua_setglobal(L, "last_RESOURCE_REQUEST");
}

void parse_SCALED_PRESSURE3(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SCALED_PRESSURE3(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SCALED_PRESSURE3 == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_scaled_pressure3_t msg_scaled_pressure3;
    mavlink_msg_scaled_pressure3_decode(&msg, & msg_scaled_pressure3);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_scaled_pressure3.time_boot_ms);
    push_value(L, "press_abs", msg_scaled_pressure3.press_abs);
    push_value(L, "press_diff", msg_scaled_pressure3.press_diff);
    push_value(L, "temperature", msg_scaled_pressure3.temperature);
    lua_setglobal(L, "last_SCALED_PRESSURE3");
}

void parse_FOLLOW_TARGET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_FOLLOW_TARGET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_FOLLOW_TARGET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_follow_target_t msg_follow_target;
    mavlink_msg_follow_target_decode(&msg, & msg_follow_target);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "timestamp", msg_follow_target.timestamp);
    push_value(L, "est_capabilities", msg_follow_target.est_capabilities);
    push_value(L, "lat", msg_follow_target.lat);
    push_value(L, "lon", msg_follow_target.lon);
    push_value(L, "alt", msg_follow_target.alt);
    lua_pushstring(L, "vel");
    lua_newtable(L);
    for (int i=0; i<3;i++) {
        push_value(L, i, msg_follow_target.vel[i]);
    } // end array of 3
    lua_rawset(L, -3);    lua_pushstring(L, "acc");
    lua_newtable(L);
    for (int i=0; i<3;i++) {
        push_value(L, i, msg_follow_target.acc[i]);
    } // end array of 3
    lua_rawset(L, -3);    lua_pushstring(L, "attitude_q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_follow_target.attitude_q[i]);
    } // end array of 4
    lua_rawset(L, -3);    lua_pushstring(L, "rates");
    lua_newtable(L);
    for (int i=0; i<3;i++) {
        push_value(L, i, msg_follow_target.rates[i]);
    } // end array of 3
    lua_rawset(L, -3);    lua_pushstring(L, "position_cov");
    lua_newtable(L);
    for (int i=0; i<3;i++) {
        push_value(L, i, msg_follow_target.position_cov[i]);
    } // end array of 3
    lua_rawset(L, -3);    push_value(L, "custom_state", msg_follow_target.custom_state);
    lua_setglobal(L, "last_FOLLOW_TARGET");
}

void parse_CONTROL_SYSTEM_STATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_CONTROL_SYSTEM_STATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_CONTROL_SYSTEM_STATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_control_system_state_t msg_control_system_state;
    mavlink_msg_control_system_state_decode(&msg, & msg_control_system_state);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_control_system_state.time_usec);
    push_value(L, "x_acc", msg_control_system_state.x_acc);
    push_value(L, "y_acc", msg_control_system_state.y_acc);
    push_value(L, "z_acc", msg_control_system_state.z_acc);
    push_value(L, "x_vel", msg_control_system_state.x_vel);
    push_value(L, "y_vel", msg_control_system_state.y_vel);
    push_value(L, "z_vel", msg_control_system_state.z_vel);
    push_value(L, "x_pos", msg_control_system_state.x_pos);
    push_value(L, "y_pos", msg_control_system_state.y_pos);
    push_value(L, "z_pos", msg_control_system_state.z_pos);
    push_value(L, "airspeed", msg_control_system_state.airspeed);
    lua_pushstring(L, "vel_variance");
    lua_newtable(L);
    for (int i=0; i<3;i++) {
        push_value(L, i, msg_control_system_state.vel_variance[i]);
    } // end array of 3
    lua_rawset(L, -3);    lua_pushstring(L, "pos_variance");
    lua_newtable(L);
    for (int i=0; i<3;i++) {
        push_value(L, i, msg_control_system_state.pos_variance[i]);
    } // end array of 3
    lua_rawset(L, -3);    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_control_system_state.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "roll_rate", msg_control_system_state.roll_rate);
    push_value(L, "pitch_rate", msg_control_system_state.pitch_rate);
    push_value(L, "yaw_rate", msg_control_system_state.yaw_rate);
    lua_setglobal(L, "last_CONTROL_SYSTEM_STATE");
}

void parse_BATTERY_STATUS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_BATTERY_STATUS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_BATTERY_STATUS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_battery_status_t msg_battery_status;
    mavlink_msg_battery_status_decode(&msg, & msg_battery_status);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "id", msg_battery_status.id);
    push_value(L, "battery_function", msg_battery_status.battery_function);
    push_value(L, "type", msg_battery_status.type);
    push_value(L, "temperature", msg_battery_status.temperature);
    lua_pushstring(L, "voltages");
    lua_newtable(L);
    for (int i=0; i<10;i++) {
        push_value(L, i, msg_battery_status.voltages[i]);
    } // end array of 10
    lua_rawset(L, -3);    push_value(L, "current_battery", msg_battery_status.current_battery);
    push_value(L, "current_consumed", msg_battery_status.current_consumed);
    push_value(L, "energy_consumed", msg_battery_status.energy_consumed);
    push_value(L, "battery_remaining", msg_battery_status.battery_remaining);
    lua_setglobal(L, "last_BATTERY_STATUS");
}

void parse_AUTOPILOT_VERSION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_AUTOPILOT_VERSION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_AUTOPILOT_VERSION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_autopilot_version_t msg_autopilot_version;
    mavlink_msg_autopilot_version_decode(&msg, & msg_autopilot_version);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "capabilities", msg_autopilot_version.capabilities);
    push_value(L, "flight_sw_version", msg_autopilot_version.flight_sw_version);
    push_value(L, "middleware_sw_version", msg_autopilot_version.middleware_sw_version);
    push_value(L, "os_sw_version", msg_autopilot_version.os_sw_version);
    push_value(L, "board_version", msg_autopilot_version.board_version);
    lua_pushstring(L, "flight_custom_version");
    lua_newtable(L);
    for (int i=0; i<8;i++) {
        push_value(L, i, msg_autopilot_version.flight_custom_version[i]);
    } // end array of 8
    lua_rawset(L, -3);    lua_pushstring(L, "middleware_custom_version");
    lua_newtable(L);
    for (int i=0; i<8;i++) {
        push_value(L, i, msg_autopilot_version.middleware_custom_version[i]);
    } // end array of 8
    lua_rawset(L, -3);    lua_pushstring(L, "os_custom_version");
    lua_newtable(L);
    for (int i=0; i<8;i++) {
        push_value(L, i, msg_autopilot_version.os_custom_version[i]);
    } // end array of 8
    lua_rawset(L, -3);    push_value(L, "vendor_id", msg_autopilot_version.vendor_id);
    push_value(L, "product_id", msg_autopilot_version.product_id);
    push_value(L, "uid", msg_autopilot_version.uid);
    lua_setglobal(L, "last_AUTOPILOT_VERSION");
}

void parse_LANDING_TARGET(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_LANDING_TARGET(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_LANDING_TARGET == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_landing_target_t msg_landing_target;
    mavlink_msg_landing_target_decode(&msg, & msg_landing_target);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_landing_target.time_usec);
    push_value(L, "target_num", msg_landing_target.target_num);
    push_value(L, "frame", msg_landing_target.frame);
    push_value(L, "angle_x", msg_landing_target.angle_x);
    push_value(L, "angle_y", msg_landing_target.angle_y);
    push_value(L, "distance", msg_landing_target.distance);
    push_value(L, "size_x", msg_landing_target.size_x);
    push_value(L, "size_y", msg_landing_target.size_y);
    lua_setglobal(L, "last_LANDING_TARGET");
}

void parse_ESTIMATOR_STATUS(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ESTIMATOR_STATUS(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ESTIMATOR_STATUS == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_estimator_status_t msg_estimator_status;
    mavlink_msg_estimator_status_decode(&msg, & msg_estimator_status);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_estimator_status.time_usec);
    push_value(L, "flags", msg_estimator_status.flags);
    push_value(L, "vel_ratio", msg_estimator_status.vel_ratio);
    push_value(L, "pos_horiz_ratio", msg_estimator_status.pos_horiz_ratio);
    push_value(L, "pos_vert_ratio", msg_estimator_status.pos_vert_ratio);
    push_value(L, "mag_ratio", msg_estimator_status.mag_ratio);
    push_value(L, "hagl_ratio", msg_estimator_status.hagl_ratio);
    push_value(L, "tas_ratio", msg_estimator_status.tas_ratio);
    push_value(L, "pos_horiz_accuracy", msg_estimator_status.pos_horiz_accuracy);
    push_value(L, "pos_vert_accuracy", msg_estimator_status.pos_vert_accuracy);
    lua_setglobal(L, "last_ESTIMATOR_STATUS");
}

void parse_WIND_COV(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_WIND_COV(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_WIND_COV == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_wind_cov_t msg_wind_cov;
    mavlink_msg_wind_cov_decode(&msg, & msg_wind_cov);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_wind_cov.time_usec);
    push_value(L, "wind_x", msg_wind_cov.wind_x);
    push_value(L, "wind_y", msg_wind_cov.wind_y);
    push_value(L, "wind_z", msg_wind_cov.wind_z);
    push_value(L, "var_horiz", msg_wind_cov.var_horiz);
    push_value(L, "var_vert", msg_wind_cov.var_vert);
    push_value(L, "wind_alt", msg_wind_cov.wind_alt);
    push_value(L, "horiz_accuracy", msg_wind_cov.horiz_accuracy);
    push_value(L, "vert_accuracy", msg_wind_cov.vert_accuracy);
    lua_setglobal(L, "last_WIND_COV");
}

void parse_GPS_INPUT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_INPUT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_INPUT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_input_t msg_gps_input;
    mavlink_msg_gps_input_decode(&msg, & msg_gps_input);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_gps_input.time_usec);
    push_value(L, "gps_id", msg_gps_input.gps_id);
    push_value(L, "ignore_flags", msg_gps_input.ignore_flags);
    push_value(L, "time_week_ms", msg_gps_input.time_week_ms);
    push_value(L, "time_week", msg_gps_input.time_week);
    push_value(L, "fix_type", msg_gps_input.fix_type);
    push_value(L, "lat", msg_gps_input.lat);
    push_value(L, "lon", msg_gps_input.lon);
    push_value(L, "alt", msg_gps_input.alt);
    push_value(L, "hdop", msg_gps_input.hdop);
    push_value(L, "vdop", msg_gps_input.vdop);
    push_value(L, "vn", msg_gps_input.vn);
    push_value(L, "ve", msg_gps_input.ve);
    push_value(L, "vd", msg_gps_input.vd);
    push_value(L, "speed_accuracy", msg_gps_input.speed_accuracy);
    push_value(L, "horiz_accuracy", msg_gps_input.horiz_accuracy);
    push_value(L, "vert_accuracy", msg_gps_input.vert_accuracy);
    push_value(L, "satellites_visible", msg_gps_input.satellites_visible);
    lua_setglobal(L, "last_GPS_INPUT");
}

void parse_GPS_RTCM_DATA(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_GPS_RTCM_DATA(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_GPS_RTCM_DATA == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_gps_rtcm_data_t msg_gps_rtcm_data;
    mavlink_msg_gps_rtcm_data_decode(&msg, & msg_gps_rtcm_data);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "flags", msg_gps_rtcm_data.flags);
    push_value(L, "len", msg_gps_rtcm_data.len);
    lua_pushstring(L, "data");
    lua_newtable(L);
    for (int i=0; i<180;i++) {
        push_value(L, i, msg_gps_rtcm_data.data[i]);
    } // end array of 180
    lua_rawset(L, -3);    lua_setglobal(L, "last_GPS_RTCM_DATA");
}

void parse_HIGH_LATENCY(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HIGH_LATENCY(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HIGH_LATENCY == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_high_latency_t msg_high_latency;
    mavlink_msg_high_latency_decode(&msg, & msg_high_latency);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "base_mode", msg_high_latency.base_mode);
    push_value(L, "custom_mode", msg_high_latency.custom_mode);
    push_value(L, "landed_state", msg_high_latency.landed_state);
    push_value(L, "roll", msg_high_latency.roll);
    push_value(L, "pitch", msg_high_latency.pitch);
    push_value(L, "heading", msg_high_latency.heading);
    push_value(L, "throttle", msg_high_latency.throttle);
    push_value(L, "heading_sp", msg_high_latency.heading_sp);
    push_value(L, "latitude", msg_high_latency.latitude);
    push_value(L, "longitude", msg_high_latency.longitude);
    push_value(L, "altitude_amsl", msg_high_latency.altitude_amsl);
    push_value(L, "altitude_sp", msg_high_latency.altitude_sp);
    push_value(L, "airspeed", msg_high_latency.airspeed);
    push_value(L, "airspeed_sp", msg_high_latency.airspeed_sp);
    push_value(L, "groundspeed", msg_high_latency.groundspeed);
    push_value(L, "climb_rate", msg_high_latency.climb_rate);
    push_value(L, "gps_nsat", msg_high_latency.gps_nsat);
    push_value(L, "gps_fix_type", msg_high_latency.gps_fix_type);
    push_value(L, "battery_remaining", msg_high_latency.battery_remaining);
    push_value(L, "temperature", msg_high_latency.temperature);
    push_value(L, "temperature_air", msg_high_latency.temperature_air);
    push_value(L, "failsafe", msg_high_latency.failsafe);
    push_value(L, "wp_num", msg_high_latency.wp_num);
    push_value(L, "wp_distance", msg_high_latency.wp_distance);
    lua_setglobal(L, "last_HIGH_LATENCY");
}

void parse_VIBRATION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_VIBRATION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_VIBRATION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_vibration_t msg_vibration;
    mavlink_msg_vibration_decode(&msg, & msg_vibration);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_usec", msg_vibration.time_usec);
    push_value(L, "vibration_x", msg_vibration.vibration_x);
    push_value(L, "vibration_y", msg_vibration.vibration_y);
    push_value(L, "vibration_z", msg_vibration.vibration_z);
    push_value(L, "clipping_0", msg_vibration.clipping_0);
    push_value(L, "clipping_1", msg_vibration.clipping_1);
    push_value(L, "clipping_2", msg_vibration.clipping_2);
    lua_setglobal(L, "last_VIBRATION");
}

void parse_HOME_POSITION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_HOME_POSITION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_HOME_POSITION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_home_position_t msg_home_position;
    mavlink_msg_home_position_decode(&msg, & msg_home_position);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "latitude", msg_home_position.latitude);
    push_value(L, "longitude", msg_home_position.longitude);
    push_value(L, "altitude", msg_home_position.altitude);
    push_value(L, "x", msg_home_position.x);
    push_value(L, "y", msg_home_position.y);
    push_value(L, "z", msg_home_position.z);
    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_home_position.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "approach_x", msg_home_position.approach_x);
    push_value(L, "approach_y", msg_home_position.approach_y);
    push_value(L, "approach_z", msg_home_position.approach_z);
    lua_setglobal(L, "last_HOME_POSITION");
}

void parse_SET_HOME_POSITION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_SET_HOME_POSITION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_SET_HOME_POSITION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_set_home_position_t msg_set_home_position;
    mavlink_msg_set_home_position_decode(&msg, & msg_set_home_position);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_system", msg_set_home_position.target_system);
    push_value(L, "latitude", msg_set_home_position.latitude);
    push_value(L, "longitude", msg_set_home_position.longitude);
    push_value(L, "altitude", msg_set_home_position.altitude);
    push_value(L, "x", msg_set_home_position.x);
    push_value(L, "y", msg_set_home_position.y);
    push_value(L, "z", msg_set_home_position.z);
    lua_pushstring(L, "q");
    lua_newtable(L);
    for (int i=0; i<4;i++) {
        push_value(L, i, msg_set_home_position.q[i]);
    } // end array of 4
    lua_rawset(L, -3);    push_value(L, "approach_x", msg_set_home_position.approach_x);
    push_value(L, "approach_y", msg_set_home_position.approach_y);
    push_value(L, "approach_z", msg_set_home_position.approach_z);
    lua_setglobal(L, "last_SET_HOME_POSITION");
}

void parse_MESSAGE_INTERVAL(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MESSAGE_INTERVAL(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MESSAGE_INTERVAL == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_message_interval_t msg_message_interval;
    mavlink_msg_message_interval_decode(&msg, & msg_message_interval);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "message_id", msg_message_interval.message_id);
    push_value(L, "interval_us", msg_message_interval.interval_us);
    lua_setglobal(L, "last_MESSAGE_INTERVAL");
}

void parse_EXTENDED_SYS_STATE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_EXTENDED_SYS_STATE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_EXTENDED_SYS_STATE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_extended_sys_state_t msg_extended_sys_state;
    mavlink_msg_extended_sys_state_decode(&msg, & msg_extended_sys_state);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "vtol_state", msg_extended_sys_state.vtol_state);
    push_value(L, "landed_state", msg_extended_sys_state.landed_state);
    lua_setglobal(L, "last_EXTENDED_SYS_STATE");
}

void parse_ADSB_VEHICLE(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_ADSB_VEHICLE(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_ADSB_VEHICLE == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_adsb_vehicle_t msg_adsb_vehicle;
    mavlink_msg_adsb_vehicle_decode(&msg, & msg_adsb_vehicle);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "ICAO_address", msg_adsb_vehicle.ICAO_address);
    push_value(L, "lat", msg_adsb_vehicle.lat);
    push_value(L, "lon", msg_adsb_vehicle.lon);
    push_value(L, "altitude_type", msg_adsb_vehicle.altitude_type);
    push_value(L, "altitude", msg_adsb_vehicle.altitude);
    push_value(L, "heading", msg_adsb_vehicle.heading);
    push_value(L, "hor_velocity", msg_adsb_vehicle.hor_velocity);
    push_value(L, "ver_velocity", msg_adsb_vehicle.ver_velocity);
    push_value(L, "callsign", msg_adsb_vehicle.callsign);
    push_value(L, "emitter_type", msg_adsb_vehicle.emitter_type);
    push_value(L, "tslc", msg_adsb_vehicle.tslc);
    push_value(L, "flags", msg_adsb_vehicle.flags);
    push_value(L, "squawk", msg_adsb_vehicle.squawk);
    lua_setglobal(L, "last_ADSB_VEHICLE");
}

void parse_COLLISION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_COLLISION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_COLLISION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_collision_t msg_collision;
    mavlink_msg_collision_decode(&msg, & msg_collision);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "src", msg_collision.src);
    push_value(L, "id", msg_collision.id);
    push_value(L, "action", msg_collision.action);
    push_value(L, "threat_level", msg_collision.threat_level);
    push_value(L, "time_to_minimum_delta", msg_collision.time_to_minimum_delta);
    push_value(L, "altitude_minimum_delta", msg_collision.altitude_minimum_delta);
    push_value(L, "horizontal_minimum_delta", msg_collision.horizontal_minimum_delta);
    lua_setglobal(L, "last_COLLISION");
}

void parse_V2_EXTENSION(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_V2_EXTENSION(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_V2_EXTENSION == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_v2_extension_t msg_v2_extension;
    mavlink_msg_v2_extension_decode(&msg, & msg_v2_extension);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "target_network", msg_v2_extension.target_network);
    push_value(L, "target_system", msg_v2_extension.target_system);
    push_value(L, "target_component", msg_v2_extension.target_component);
    push_value(L, "message_type", msg_v2_extension.message_type);
    lua_pushstring(L, "payload");
    lua_newtable(L);
    for (int i=0; i<249;i++) {
        push_value(L, i, msg_v2_extension.payload[i]);
    } // end array of 249
    lua_rawset(L, -3);    lua_setglobal(L, "last_V2_EXTENSION");
}

void parse_MEMORY_VECT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_MEMORY_VECT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_MEMORY_VECT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_memory_vect_t msg_memory_vect;
    mavlink_msg_memory_vect_decode(&msg, & msg_memory_vect);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "address", msg_memory_vect.address);
    push_value(L, "ver", msg_memory_vect.ver);
    push_value(L, "type", msg_memory_vect.type);
    lua_pushstring(L, "value");
    lua_newtable(L);
    for (int i=0; i<32;i++) {
        push_value(L, i, msg_memory_vect.value[i]);
    } // end array of 32
    lua_rawset(L, -3);    lua_setglobal(L, "last_MEMORY_VECT");
}

void parse_DEBUG_VECT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_DEBUG_VECT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_DEBUG_VECT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_debug_vect_t msg_debug_vect;
    mavlink_msg_debug_vect_decode(&msg, & msg_debug_vect);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "name", msg_debug_vect.name);
    push_value(L, "time_usec", msg_debug_vect.time_usec);
    push_value(L, "x", msg_debug_vect.x);
    push_value(L, "y", msg_debug_vect.y);
    push_value(L, "z", msg_debug_vect.z);
    lua_setglobal(L, "last_DEBUG_VECT");
}

void parse_NAMED_VALUE_FLOAT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_NAMED_VALUE_FLOAT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_NAMED_VALUE_FLOAT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_named_value_float_t msg_named_value_float;
    mavlink_msg_named_value_float_decode(&msg, & msg_named_value_float);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_named_value_float.time_boot_ms);
    push_value(L, "name", msg_named_value_float.name);
    push_value(L, "value", msg_named_value_float.value);
    lua_setglobal(L, "last_NAMED_VALUE_FLOAT");
}

void parse_NAMED_VALUE_INT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_NAMED_VALUE_INT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_NAMED_VALUE_INT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_named_value_int_t msg_named_value_int;
    mavlink_msg_named_value_int_decode(&msg, & msg_named_value_int);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_named_value_int.time_boot_ms);
    push_value(L, "name", msg_named_value_int.name);
    push_value(L, "value", msg_named_value_int.value);
    lua_setglobal(L, "last_NAMED_VALUE_INT");
}

void parse_STATUSTEXT(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_STATUSTEXT(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_STATUSTEXT == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_statustext_t msg_statustext;
    mavlink_msg_statustext_decode(&msg, & msg_statustext);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "severity", msg_statustext.severity);
    push_value(L, "text", msg_statustext.text);
    lua_setglobal(L, "last_STATUSTEXT");
}

void parse_DEBUG(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_DEBUG(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_DEBUG == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_debug_t msg_debug;
    mavlink_msg_debug_decode(&msg, & msg_debug);

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

    push_value(L, "time_boot_ms", msg_debug.time_boot_ms);
    push_value(L, "ind", msg_debug.ind);
    push_value(L, "value", msg_debug.value);
    lua_setglobal(L, "last_DEBUG");
}

std::map<int, ParseFuncPtr> funcmap =  {
    { 0, parse_HEARTBEAT },
    { 1, parse_SYS_STATUS },
    { 2, parse_SYSTEM_TIME },
    { 4, parse_PING },
    { 5, parse_CHANGE_OPERATOR_CONTROL },
    { 6, parse_CHANGE_OPERATOR_CONTROL_ACK },
    { 7, parse_AUTH_KEY },
    { 11, parse_SET_MODE },
    { 20, parse_PARAM_REQUEST_READ },
    { 21, parse_PARAM_REQUEST_LIST },
    { 22, parse_PARAM_VALUE },
    { 23, parse_PARAM_SET },
    { 24, parse_GPS_RAW_INT },
    { 25, parse_GPS_STATUS },
    { 26, parse_SCALED_IMU },
    { 27, parse_RAW_IMU },
    { 28, parse_RAW_PRESSURE },
    { 29, parse_SCALED_PRESSURE },
    { 30, parse_ATTITUDE },
    { 31, parse_ATTITUDE_QUATERNION },
    { 32, parse_LOCAL_POSITION_NED },
    { 33, parse_GLOBAL_POSITION_INT },
    { 34, parse_RC_CHANNELS_SCALED },
    { 35, parse_RC_CHANNELS_RAW },
    { 36, parse_SERVO_OUTPUT_RAW },
    { 37, parse_MISSION_REQUEST_PARTIAL_LIST },
    { 38, parse_MISSION_WRITE_PARTIAL_LIST },
    { 39, parse_MISSION_ITEM },
    { 40, parse_MISSION_REQUEST },
    { 41, parse_MISSION_SET_CURRENT },
    { 42, parse_MISSION_CURRENT },
    { 43, parse_MISSION_REQUEST_LIST },
    { 44, parse_MISSION_COUNT },
    { 45, parse_MISSION_CLEAR_ALL },
    { 46, parse_MISSION_ITEM_REACHED },
    { 47, parse_MISSION_ACK },
    { 48, parse_SET_GPS_GLOBAL_ORIGIN },
    { 49, parse_GPS_GLOBAL_ORIGIN },
    { 50, parse_PARAM_MAP_RC },
    { 51, parse_MISSION_REQUEST_INT },
    { 54, parse_SAFETY_SET_ALLOWED_AREA },
    { 55, parse_SAFETY_ALLOWED_AREA },
    { 61, parse_ATTITUDE_QUATERNION_COV },
    { 62, parse_NAV_CONTROLLER_OUTPUT },
    { 63, parse_GLOBAL_POSITION_INT_COV },
    { 64, parse_LOCAL_POSITION_NED_COV },
    { 65, parse_RC_CHANNELS },
    { 66, parse_REQUEST_DATA_STREAM },
    { 67, parse_DATA_STREAM },
    { 69, parse_MANUAL_CONTROL },
    { 70, parse_RC_CHANNELS_OVERRIDE },
    { 73, parse_MISSION_ITEM_INT },
    { 74, parse_VFR_HUD },
    { 75, parse_COMMAND_INT },
    { 76, parse_COMMAND_LONG },
    { 77, parse_COMMAND_ACK },
    { 81, parse_MANUAL_SETPOINT },
    { 82, parse_SET_ATTITUDE_TARGET },
    { 83, parse_ATTITUDE_TARGET },
    { 84, parse_SET_POSITION_TARGET_LOCAL_NED },
    { 85, parse_POSITION_TARGET_LOCAL_NED },
    { 86, parse_SET_POSITION_TARGET_GLOBAL_INT },
    { 87, parse_POSITION_TARGET_GLOBAL_INT },
    { 89, parse_LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET },
    { 90, parse_HIL_STATE },
    { 91, parse_HIL_CONTROLS },
    { 92, parse_HIL_RC_INPUTS_RAW },
    { 93, parse_HIL_ACTUATOR_CONTROLS },
    { 100, parse_OPTICAL_FLOW },
    { 101, parse_GLOBAL_VISION_POSITION_ESTIMATE },
    { 102, parse_VISION_POSITION_ESTIMATE },
    { 103, parse_VISION_SPEED_ESTIMATE },
    { 104, parse_VICON_POSITION_ESTIMATE },
    { 105, parse_HIGHRES_IMU },
    { 106, parse_OPTICAL_FLOW_RAD },
    { 107, parse_HIL_SENSOR },
    { 108, parse_SIM_STATE },
    { 109, parse_RADIO_STATUS },
    { 110, parse_FILE_TRANSFER_PROTOCOL },
    { 111, parse_TIMESYNC },
    { 112, parse_CAMERA_TRIGGER },
    { 113, parse_HIL_GPS },
    { 114, parse_HIL_OPTICAL_FLOW },
    { 115, parse_HIL_STATE_QUATERNION },
    { 116, parse_SCALED_IMU2 },
    { 117, parse_LOG_REQUEST_LIST },
    { 118, parse_LOG_ENTRY },
    { 119, parse_LOG_REQUEST_DATA },
    { 120, parse_LOG_DATA },
    { 121, parse_LOG_ERASE },
    { 122, parse_LOG_REQUEST_END },
    { 123, parse_GPS_INJECT_DATA },
    { 124, parse_GPS2_RAW },
    { 125, parse_POWER_STATUS },
    { 126, parse_SERIAL_CONTROL },
    { 127, parse_GPS_RTK },
    { 128, parse_GPS2_RTK },
    { 129, parse_SCALED_IMU3 },
    { 130, parse_DATA_TRANSMISSION_HANDSHAKE },
    { 131, parse_ENCAPSULATED_DATA },
    { 132, parse_DISTANCE_SENSOR },
    { 133, parse_TERRAIN_REQUEST },
    { 134, parse_TERRAIN_DATA },
    { 135, parse_TERRAIN_CHECK },
    { 136, parse_TERRAIN_REPORT },
    { 137, parse_SCALED_PRESSURE2 },
    { 138, parse_ATT_POS_MOCAP },
    { 139, parse_SET_ACTUATOR_CONTROL_TARGET },
    { 140, parse_ACTUATOR_CONTROL_TARGET },
    { 141, parse_ALTITUDE },
    { 142, parse_RESOURCE_REQUEST },
    { 143, parse_SCALED_PRESSURE3 },
    { 144, parse_FOLLOW_TARGET },
    { 146, parse_CONTROL_SYSTEM_STATE },
    { 147, parse_BATTERY_STATUS },
    { 148, parse_AUTOPILOT_VERSION },
    { 149, parse_LANDING_TARGET },
    { 230, parse_ESTIMATOR_STATUS },
    { 231, parse_WIND_COV },
    { 232, parse_GPS_INPUT },
    { 233, parse_GPS_RTCM_DATA },
    { 234, parse_HIGH_LATENCY },
    { 241, parse_VIBRATION },
    { 242, parse_HOME_POSITION },
    { 243, parse_SET_HOME_POSITION },
    { 244, parse_MESSAGE_INTERVAL },
    { 245, parse_EXTENDED_SYS_STATE },
    { 246, parse_ADSB_VEHICLE },
    { 247, parse_COLLISION },
    { 248, parse_V2_EXTENSION },
    { 249, parse_MEMORY_VECT },
    { 250, parse_DEBUG_VECT },
    { 251, parse_NAMED_VALUE_FLOAT },
    { 252, parse_NAMED_VALUE_INT },
    { 253, parse_STATUSTEXT },
    { 254, parse_DEBUG },
};

