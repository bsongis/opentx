#!/usr/bin/env python
'''
parse a MAVLink protocol XML file and generate C and Lua code for OpenTX

Released under GNU GPL version 2 or later
Copyright (C) 2018 Holger Steinhaus

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
'''

import sys, textwrap, os, re
import mavparse, mavtemplate

t = mavtemplate.MAVTemplate()


###############################################################################
def mavfmt(field):
    '''work out the struct format for a type'''
    map = {
        'float'    : 'f',
        'double'   : 'd',
        'char'     : 'c',
        'int8_t'   : 'b',
        'uint8_t'  : 'B',
        'uint8_t_mavlink_version'  : 'B',
        'int16_t'  : 'h',
        'uint16_t' : 'H',
        'int32_t'  : 'i',
        'uint32_t' : 'I',
        'int64_t'  : 'q',
        'uint64_t' : 'Q',
        }

    if field.array_length:
        if field.type in ['char', 'int8_t', 'uint8_t']:
            return str(field.array_length)+'s'
        return str(field.array_length)+map[field.type]
    return map[field.type]


###############################################################################
def generate_lua_preamble(outf):
    t.write(outf,
"""
-- MAVLink enums for Lua - generated by mavlink_lua.py - DO NOT EDIT!

module("mavlink"parseage.seeall)

""" )


###############################################################################
def generate_lua_msg_table(outf, msgs):
    t.write(outf, """
msg = {
""")
    for msg in msgs:
        assert isinstance(msg, mavparse.MAVType)
        t.write(outf, """    [${msgid}] = '${msgname}', -- ${desc}'\n""", {'msgid':msg.id, 'msgname':msg.name, 'desc':msg.description.replace("\n", "")})

    for msg in msgs:
        assert isinstance(msg, mavparse.MAVType)
        t.write(outf, """    ['${msgname}'] = ${msgid}, -- ${desc}'\n""", {'msgid':msg.id, 'msgname':msg.name, 'desc':msg.description.replace("\n", "")})

    t.write(outf, """
}

""")


###############################################################################
def generate_lua_enum(outf, enum):
    assert isinstance(enum, mavparse.MAVEnum)
    t.write(outf, """${enumname} = {\n""", {'enumname':enum.name})
    t.write(outf, """    -- ${desc}\n""", {'desc':enum.description})

    for ee in enum.entry:
        assert isinstance(ee, mavparse.MAVEnumEntry)
        t.write(outf,"""    ['${eename}'] = ${eevalue} -- ${eedesc}\n""", {'eename':ee.name, 'eevalue':ee.value, 'eedesc':ee.description})

    t.write(outf, '}\n\n')


###############################################################################
def generate_h(outf, msgs):
    t.write(outf,
"""
/* MAVLink2Lua - generated by mavgen_lua.py - DO NOT EDIT! */

#pragma once

#include <lua.hpp>

#include <mavlink_types.h>
#include <common/mavlink.h>

#include <map>

// prototype for pointer to parse_* functions
typedef void (*ParseFuncPtr)(lua_State*, const mavlink_message_t&);

// map of parse functions by message_id (24bit int with gaps in between)
extern std::map<int, ParseFuncPtr> funcmap;

// other functions providing access to MAVLink-related data/metadata
extern void provide_MavlinkStatus(lua_State* L, const mavlink_status_t& status);

""")


###############################################################################
def generate_c_preamble(outf, msgs):
    print("Generating preamble")
    t.write(outf,
"""
/* MAVLink2Lua - generated by mavgen_lua.py - DO NOT EDIT! */

#include "mavlink2lua.h"

#include <common/mavlink.h>
#include <ardupilotmega/mavlink.h>
#include "opentx.h"

""")
    # message includes
    for msg in msgs:
        assert isinstance(msg, mavparse.MAVType)
        t.write(outf, """#include <${dialect}/mavlink_msg_${msgname}.h>\n""", {'dialect':msg.basename, 'msgname':msg.name_lower})
    t.write(outf, """\n\n""")

    # helper functions for code size reduction
    t.write(outf,
"""

void push_value(lua_State* L, const char* name, const char* text)
{
    lua_pushstring(L, name);
    lua_pushstring(L, text);
    lua_rawset(L, -3);
}

void push_value(lua_State* L, const char* name, const double num)
{
    lua_pushstring(L, name);
    lua_pushnumber(L, num);
    lua_rawset(L, -3);
}

void push_value(lua_State* L, const int i, const char* text)
{
    lua_pushnumber(L, i);
    lua_pushstring(L, text);
    lua_rawset(L, -3);
}

void push_value(lua_State* L, const int i, const double num)
{
    lua_pushnumber(L, i);
    lua_pushnumber(L, num);
    lua_rawset(L, -3);
}

void provide_MavlinkStatus(lua_State* L, const mavlink_status_t& status)
{
    TRACE("provide_MavlinkStatus(%x)", L);
    assert(L);

    lua_newtable(L);
    push_value(L, "msg_received", status.msg_received);
    push_value(L, "buffer_overrun", status.buffer_overrun);
    push_value(L, "parse_error", status.parse_error);
    push_value(L, "parse_state", status.parse_state);
    push_value(L, "packet_idx", status.packet_idx);
    push_value(L, "current_rx_seq", status.current_rx_seq);
    push_value(L, "current_tx_seq", status.current_tx_seq);
    push_value(L, "packet_rx_success_count", status.packet_rx_success_count);
    push_value(L, "packet_rx_drop_count", status.packet_rx_drop_count);
    push_value(L, "flags", status.flags);
    push_value(L, "signature_wait", status.signature_wait);
    // not supported yet: struct __mavlink_signing *signing;
    // not supported yet: struct __mavlink_signing_streams *signing_streams;
    lua_setglobal(L, "link_status");
}

""" )

###############################################################################
def generate_c_msg_function(outf, msg):
    assert isinstance(msg, mavparse.MAVType)

    t.write(outf, """
void parse_${msgname}(lua_State* L, const mavlink_message_t& msg)
{
    TRACE("parse_${msgname}(%x, %x)", L, msg.msgid);
    assert(MAVLINK_STX == msg.magic || MAVLINK_STX_MAVLINK1 == msg.magic);
    assert(MAVLINK_MSG_ID_${msgname} == (msg.msgid & 0xFFFFFF));
    assert(L);

    mavlink_${type}_t msg_${type};
    mavlink_msg_${type}_decode(&msg, & msg_${type});

    lua_newtable(L);
    push_value(L, "incompat_flags", msg.incompat_flags);
    push_value(L, "compat_flags", msg.compat_flags);
    push_value(L, "seq", msg.seq);
    push_value(L, "sysid", msg.sysid);
    push_value(L, "compid", msg.compid);

""", {'msgname':msg.name, 'type':msg.name_lower})

    for f in msg.fields:
        assert isinstance(f, mavparse.MAVField)

        # process value
        if f.array_length and not "char" in f.type:
            # array, except strings
            # important: maintain loop, do not unroll!
            t.write(outf, """    lua_pushstring(L, "${fieldname}");\n""", {'fieldname': f.name, 'type':msg.name_lower})
            t.write(outf, """    lua_newtable(L);\n""")
            t.write(outf, """    for (int i=0; i<${max};i++) {\n""", {"max":f.array_length})
            t.write(outf, """        push_value(L, i, msg_${type}.${fieldname}[i]);\n""", {'fieldname': f.name, 'type':msg.name_lower})
            t.write(outf, """    } // end array of ${len}\n""", {"len":f.array_length})
            t.write(outf, """    lua_rawset(L, -3);""")
        else:
            # scalars and strings
            t.write(outf, """    push_value(L, "${fieldname}", msg_${type}.${fieldname});\n""", {'fieldname': f.name, 'type':msg.name_lower})

    t.write(outf, """
    lua_setglobal(L, "${global}");
}\n\n""", {'global':'last_' + msg.name})


###############################################################################
def generate_c_funcmap(outf, msgs):
    t.write(outf, """\nstd::map<int, ParseFuncPtr> funcmap =  {\n""");

    for msg in msgs:
        assert isinstance(msg, mavparse.MAVType)
        t.write(outf, """    { ${msgid}, parse_${name} },\n""", {'msgid':msg.id, 'name':msg.name });


    t.write(outf, """};\n\n""");


###############################################################################
def generate(basename, xml):
    '''generate Lua and C code for OpenTX'''

    filename_lua = basename + '.lua'
    filename_cpp = basename + '2lua.cpp'
    filename_h = basename + '2lua.h'

    msgs = []
    enums = []
    filelist = []
    for x in xml:
        msgs.extend(x.message)
        enums.extend(x.enum)
        filelist.append(os.path.basename(x.filename))

    for m in msgs:
        if xml[0].little_endian:
            m.fmtstr = '<'
        else:
            m.fmtstr = '>'
        for f in m.ordered_fields:
            m.fmtstr += mavfmt(f)
        m.order_map = [ 0 ] * len(m.fieldnames)
        for i in range(0, len(m.fieldnames)):
            m.order_map[i] = m.ordered_fieldnames.index(m.fieldnames[i])

    file_lua = open(filename_lua, "w")
    file_cpp = open(filename_cpp, "w")
    file_h = open(filename_h, "w")

    print("Generating %s" % filename_lua)
    generate_lua_preamble(file_lua)
    generate_lua_msg_table(file_lua, msgs)
    for e in enums:
        generate_lua_enum(file_lua, e)
    file_lua.close()

    print("Generating %s" % filename_h)
    generate_h(file_h, msgs)
    file_h.close()

    print("Generating %s" % filename_cpp)
    generate_c_preamble(file_cpp, msgs)
    for m in msgs:
        generate_c_msg_function(file_cpp, m)
    generate_c_funcmap(file_cpp, msgs)
    file_cpp.close()

    print("Generated %s OK" % filename_lua)

