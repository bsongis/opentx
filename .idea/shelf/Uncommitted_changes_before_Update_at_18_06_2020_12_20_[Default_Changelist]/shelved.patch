Index: radio/src/thirdparty/libopenui/src/window.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright (C) OpenTX\n *\n * Source:\n *  https://github.com/opentx/libopenui\n *\n * This file is a part of libopenui library.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 3 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n */\n\n#include \"window.h\"\n#include \"touch.h\"\n\nWindow * Window::focusWindow = nullptr;\nWindow * Window::slidingWindow = nullptr;\nstd::list<Window *> Window::trash;\n\nWindow::Window(Window * parent, const rect_t & rect, WindowFlags windowFlags, LcdFlags textFlags):\n  parent(parent),\n  rect(rect),\n  innerWidth(rect.w),\n  innerHeight(rect.h),\n  windowFlags(windowFlags),\n  textFlags(textFlags)\n{\n  if (parent) {\n    parent->addChild(this, windowFlags & PUSH_FRONT);\n    if (!(windowFlags & TRANSPARENT)) {\n      invalidate();\n    }\n  }\n}\n\nWindow::~Window()\n{\n  TRACE_WINDOWS(\"Destroy %p %s\", this, getWindowDebugString().c_str());\n\n  if (focusWindow == this) {\n    focusWindow = nullptr;\n  }\n\n  deleteChildren();\n}\n\nvoid Window::attach(Window * newParent)\n{\n  if (parent)\n    detach();\n  parent = newParent;\n  newParent->addChild(this);\n}\n\nvoid Window::detach()\n{\n  if (parent) {\n    parent->removeChild(this);\n    parent = nullptr;\n  }\n}\n\nvoid Window::deleteLater(bool detach)\n{\n  TRACE_WINDOWS(\"Delete %p %s\", this, getWindowDebugString().c_str());\n\n  if (static_cast<Window *>(focusWindow) == static_cast<Window *>(this)) {\n    focusWindow = nullptr;\n  }\n\n  if (detach)\n    this->detach();\n  else\n    parent = nullptr;\n\n  if (closeHandler) {\n    closeHandler();\n  }\n\n  trash.push_back(this);\n}\n\nvoid Window::clear()\n{\n  scrollPositionX = 0;\n  scrollPositionY = 0;\n  innerWidth = rect.w;\n  innerHeight = rect.h;\n  deleteChildren();\n  invalidate();\n}\n\nvoid Window::deleteChildren()\n{\n  for (auto window: children) {\n    window->deleteLater(false);\n  }\n  children.clear();\n}\n\nvoid Window::clearFocus()\n{\n  if (focusWindow) {\n    focusWindow->onFocusLost();\n    focusWindow = nullptr;\n  }\n}\n\nvoid Window::setFocus(uint8_t flag)\n{\n  TRACE_WINDOWS(\"%s setFocus()\", getWindowDebugString().c_str());\n\n  if (focusWindow != this) {\n    clearFocus();\n    focusWindow = this;\n    if (focusHandler) {\n      focusHandler(true);\n    }\n  }\n\n  Window * parent = this->parent;\n  while (parent && parent->getWindowFlags() & FORWARD_SCROLL) {\n    parent = parent->parent;\n  }\n\n  if (parent) {\n    parent->scrollTo(this);\n    invalidate();\n  }\n}\n\nvoid Window::setScrollPositionX(coord_t value)\n{\n  auto newScrollPosition = max<coord_t>(0, min<coord_t>(innerWidth - width(), value));\n  if (newScrollPosition != scrollPositionX) {\n    scrollPositionX = newScrollPosition;\n    invalidate();\n  }\n}\n\nvoid Window::setScrollPositionY(coord_t value)\n{\n  auto newScrollPosition = min<coord_t>(innerHeight - height(), value);\n\n  if (newScrollPosition < 0 && innerHeight != INFINITE_HEIGHT) {\n    newScrollPosition = 0;\n  }\n\n  if (newScrollPosition != scrollPositionY) {\n    scrollPositionY = newScrollPosition;\n    invalidate();\n  }\n}\n\nvoid Window::scrollTo(Window * child)\n{\n  coord_t offsetX = 0;\n  coord_t offsetY = 0;\n\n  Window * parent = child->getParent();\n  while (parent && parent != this) {\n    offsetX += parent->left();\n    offsetY += parent->top();\n    parent = parent->getParent();\n  }\n\n  const rect_t rect = {\n  offsetX + child->left(),\n  offsetY + child->top(),\n    child->width(),\n    child->height()\n  };\n  scrollTo(rect);\n}\n\nvoid Window::scrollTo(const rect_t & rect)\n{\n  if (rect.top() < scrollPositionY) {\n    setScrollPositionY(pageHeight ? rect.top() - (rect.top() % pageHeight) : rect.top() - 5);\n  }\n  else if (rect.bottom() > scrollPositionY + height() - 5) {\n    setScrollPositionY(pageHeight ? rect.top() - (rect.top() % pageHeight) : rect.bottom() - height() + 5);\n  }\n\n  if (rect.left() < scrollPositionX) {\n    setScrollPositionX(pageWidth ? rect.left() - (rect.left() % pageWidth) : rect.left() - 5);\n  }\n  else if (rect.right() > scrollPositionX + width() - 5) {\n    setScrollPositionX(pageWidth ? rect.left() - (rect.left() % pageWidth) : rect.right() - width() + 5);\n  }\n}\n\nbool Window::hasOpaqueRect(const rect_t & rect) const\n{\n  if (!this->rect.contains(rect))\n    return false;\n\n  if (windowFlags & OPAQUE) {\n    return true;\n  }\n\n  for (auto child: children) {\n    if (child->hasOpaqueRect(rect))\n      return true;\n  }\n\n  return false;\n}\n\nvoid Window::fullPaint(BitmapBuffer * dc)\n{\n  bool paintNeeded = true;\n\n  coord_t xmin, xmax, ymin, ymax;\n  dc->getClippingRect(xmin, xmax, ymin, ymax);\n\n  auto firstChild = children.end();\n  while (firstChild != children.begin()) {\n    auto child = *(--firstChild);\n    if (child->hasOpaqueRect({xmin, ymin, xmax - xmin, ymax - ymin})) {\n      paintNeeded = false;\n      break;\n    }\n  }\n\n  if (windowFlags & PAINT_CHILDREN_FIRST) {\n    coord_t x = dc->getOffsetX();\n    coord_t y = dc->getOffsetY();\n    paintChildren(dc, firstChild);\n    dc->setOffset(x, y);\n    dc->setClippingRect(xmin, xmax, ymin, ymax);\n  }\n\n  if (paintNeeded) {\n    TRACE_WINDOWS_INDENT(\"%s\", getWindowDebugString().c_str());\n    paint(dc);\n#if defined(WINDOWS_INSPECT_BORDER_COLOR)\n    dc->drawSolidRect(0, 0, width(), height(), 1, WINDOWS_INSPECT_BORDER_COLOR);\n#endif\n  }\n  else {\n    TRACE_WINDOWS_INDENT(\"%s (skipped)\", getWindowDebugString().c_str());\n  }\n\n  if (!(windowFlags & NO_SCROLLBAR)) {\n    drawVerticalScrollbar(dc);\n  }\n\n  if (!(windowFlags & PAINT_CHILDREN_FIRST)) {\n    paintChildren(dc, firstChild);\n  }\n}\n\nbool Window::isChildFullSize(const Window * child) const\n{\n  return child->top() == 0 && child->height() == height() && child->left() == 0 && child->width() == width();\n}\n\nbool Window::isChildVisible(const Window * window) const\n{\n  for (auto rit = children.rbegin(); rit != children.rend(); rit++) {\n    auto child = *rit;\n    if (child == window) {\n      return true;\n    }\n    if ((child->getWindowFlags() & OPAQUE) & isChildFullSize(child)) {\n      return false;\n    }\n  }\n  return false;\n}\n\nvoid Window::paintChildren(BitmapBuffer * dc, std::list<Window *>::iterator it)\n{\n  coord_t x = dc->getOffsetX();\n  coord_t y = dc->getOffsetY();\n  coord_t xmin, xmax, ymin, ymax;\n  dc->getClippingRect(xmin, xmax, ymin, ymax);\n\n  for (; it != children.end(); it++) {\n    auto child = *it;\n\n    coord_t child_xmin = x + child->rect.x;\n    if (child_xmin >= xmax)\n      continue;\n    coord_t child_ymin = y + child->rect.y;\n    if (child_ymin >= ymax)\n      continue;\n    coord_t child_xmax = child_xmin + child->rect.w;\n    if (child_xmax <= xmin)\n      continue;\n    coord_t child_ymax = child_ymin + child->rect.h;\n    if (child_ymax <= ymin)\n      continue;\n\n    dc->setOffset(x + child->rect.x - child->scrollPositionX, y + child->rect.y - child->scrollPositionY);\n    dc->setClippingRect(max(xmin, x + child->rect.left()),\n                        min(xmax, x + child->rect.right()),\n                        max(ymin, y + child->rect.top()),\n                        min(ymax, y + child->rect.bottom()));\n    child->fullPaint(dc);\n  }\n}\n\nvoid Window::checkEvents()\n{\n  auto copy = children;\n  for (auto child: copy) {\n    child->checkEvents();\n  }\n\n  if (this == focusWindow) {\n    event_t event = getWindowEvent();\n    if (event) {\n      this->onEvent(event);\n    }\n  }\n\n  if (windowFlags & REFRESH_ALWAYS) {\n    invalidate();\n  }\n\n#if defined(HARDWARE_TOUCH)\n  if (touchState.event != TE_SLIDE) {\n    if (pageWidth) {\n      coord_t relativeScrollPosition = scrollPositionX % pageWidth;\n      if (relativeScrollPosition) {\n        setScrollPositionX(getScrollPositionX() - relativeScrollPosition + (relativeScrollPosition > pageWidth / 2 ? pageWidth : 0));\n      }\n    }\n    if (pageHeight) {\n      coord_t relativeScrollPosition = scrollPositionY % pageHeight;\n      if (relativeScrollPosition) {\n        if (relativeScrollPosition > 0)\n          setScrollPositionY(getScrollPositionY() - relativeScrollPosition + (relativeScrollPosition > pageHeight / 2 ? pageHeight : 0));\n        else\n          setScrollPositionY(getScrollPositionY() - relativeScrollPosition - (relativeScrollPosition > -pageHeight / 2 ? 0 : pageHeight));\n      }\n    }\n  }\n#endif\n}\n\nvoid Window::onEvent(event_t event)\n{\n  TRACE_WINDOWS(\"%s received event 0x%X\", Window::getWindowDebugString(\"Window\").c_str(), event);\n  if (parent) {\n    parent->onEvent(event);\n  }\n}\n\n#if defined(HARDWARE_TOUCH)\nbool Window::onTouchStart(coord_t x, coord_t y)\n{\n  for (auto it = children.rbegin(); it != children.rend(); ++it) {\n    auto child = *it;\n    if (child->rect.contains(x, y)) {\n      if (child->onTouchStart(x - child->rect.x + child->scrollPositionX, y - child->rect.y + child->scrollPositionY)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nbool Window::forwardTouchEnd(coord_t x, coord_t y)\n{\n  for (auto it = children.rbegin(); it != children.rend(); ++it) {\n    auto child = *it;\n    if (child->rect.contains(x, y)) {\n      if (child->onTouchEnd(x - child->rect.x + child->scrollPositionX, y - child->rect.y + child->scrollPositionY)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nbool Window::onTouchEnd(coord_t x, coord_t y)\n{\n  return forwardTouchEnd(x, y) ? true : (windowFlags & OPAQUE);\n}\n\nbool Window::onTouchSlide(coord_t x, coord_t y, coord_t startX, coord_t startY, coord_t slideX, coord_t slideY)\n{\n  startX += getScrollPositionX();\n  startY += getScrollPositionY();\n\n  for (auto it = children.rbegin(); it != children.rend(); ++it) {\n    auto child = *it;\n    if (child->rect.contains(startX, startY)) {\n      if (child->onTouchSlide(x - child->rect.x, y - child->rect.y, startX - child->rect.x, startY - child->rect.y, slideX, slideY)) {\n        return true;\n      }\n    }\n  }\n\n  if (slidingWindow && slidingWindow != this) {\n    return false;\n  }\n\n  if (slideY && innerHeight > rect.h) {\n    setScrollPositionY(scrollPositionY - slideY);\n    slidingWindow = this;\n    return true;\n  }\n\n  if (slideX && innerWidth > rect.w) {\n    setScrollPositionX(scrollPositionX - slideX);\n    slidingWindow = this;\n    return true;\n  }\n\n  return false;\n}\n#endif\n\nvoid Window::adjustInnerHeight()\n{\n  coord_t bottomMax = 0;\n  for (auto child: children) {\n    bottomMax = max(bottomMax, child->rect.y + child->rect.h);\n  }\n  setInnerHeight(bottomMax);\n}\n\ncoord_t Window::adjustHeight()\n{\n  adjustInnerHeight();\n  coord_t old = rect.h;\n  rect.h = innerHeight;\n  return rect.h - old;\n}\n\nvoid Window::moveWindowsTop(coord_t y, coord_t delta)\n{\n  for (auto child: children) {\n    if (child->rect.y >= y) {\n      child->rect.y += delta;\n      invalidate();\n    }\n  }\n  setInnerHeight(innerHeight + delta);\n}\n\nvoid Window::invalidate(const rect_t & rect)\n{\n  if (isVisible()) {\n    parent->invalidate({this->rect.x + rect.x - parent->scrollPositionX, this->rect.y + rect.y - parent->scrollPositionY, rect.w, rect.h});\n  }\n}\n\nvoid Window::drawVerticalScrollbar(BitmapBuffer * dc)\n{\n  if (innerHeight > rect.h) {\n    coord_t yofs = divRoundClosest(rect.h * scrollPositionY, innerHeight);\n    coord_t yhgt = divRoundClosest(rect.h * rect.h, innerHeight);\n    if (yhgt < 15)\n      yhgt = 15;\n    if (yhgt + yofs > rect.h)\n      yhgt = rect.h - yofs;\n    dc->drawSolidFilledRect(rect.w - SCROLLBAR_WIDTH, scrollPositionY + yofs, SCROLLBAR_WIDTH, yhgt, SCROLLBAR_COLOR);\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- radio/src/thirdparty/libopenui/src/window.cpp	(revision a2aff466ca9776b4fe156d823111eac8d667ae71)
+++ radio/src/thirdparty/libopenui/src/window.cpp	(date 1592471745446)
@@ -435,8 +435,8 @@
 
 coord_t Window::adjustHeight()
 {
-  adjustInnerHeight();
   coord_t old = rect.h;
+  adjustInnerHeight();
   rect.h = innerHeight;
   return rect.h - old;
 }
